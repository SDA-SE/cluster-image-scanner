apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: orchestration-job-template
  namespace: clusterscanner
spec:
  activeDeadlineSeconds: 21600 # 6h
  entrypoint: main # Entry point for job execution
  workflowSpec:
    #serviceAccountName: clusterscanner
    ttlStrategy:
      secondsAfterSuccess: 172800
      secondsAfterFailure: 172800
    artifactRepositoryRef:
      configMap: artifact-repositories
      key: default-v1
  inputs:
    parameters:
      - workflow.parameters.imageSourceListConfigMapName
      - workflow.parameters.gitSecretName
      - workflow.parameters.scanId
      - workflow.parameters.registrySecretName
      - workflow.parameters.dependencyCheckDbConfigMapName
      - workflow.parameters.defectDojoConfigMapName
      - workflow.parameters.slackTokenSecretName
      - workflow.parameters.emailSecretName
      - workflow.parameters.enforceSlackChannel
      - workflow.parameters.newVersionImageFilter
      - workflow.parameters.dependencyCheckSuppressionsConfigMapName
      - workflow.parameters.allResultsGitTarget
      - workflow.parameters.baseImageName
      - workflow.parameters.defectDojoClientImageName
      - workflow.parameters.imageSourceFetcherImageName
      - workflow.parameters.imageCollectorImageName
      - workflow.parameters.workflowRunnerImageName
      - workflow.parameters.scanDistrolessImageName
      - workflow.parameters.scanDependencyCheckImageName
      - workflow.parameters.scanMalwareImageName
      - workflow.parameters.scanRootImageName
      - workflow.parameters.scanLifetimeImageName
      - workflow.parameters.scanNewVersionImageName
      - workflow.parameters.scanSyftImageName
  templates:
    - name: main
      steps:
        - - name: fetch-image-list
            template: fetch-image-list
        - - name: run-subflow
            template: subflow
            arguments:
              artifacts:
                - name: imageList
                  from: "{{steps.fetch-image-list.outputs.artifacts.image-list-merged}}"
        - - name: notify-teams
            template: notify-teams
        - - name: git-upload-report
            template: git-upload-report
    #            when: "{{ workflow.parameters.allResultsGitTarget }} == "

    - name: fetch-image-list
      outputs:
        artifacts:
          - name: image-lists
            path: /clusterscanner/out
            archive:
              none: {}
          - name: image-list-merged
            path: /clusterscanner/out/merged/merged.json
            archive:
              none: {}
      volumes:
        - name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
          configMap:
            name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
        - name: "{{ workflow.parameters.gitSecretName }}"
          secret:
            secretName: "{{ workflow.parameters.gitSecretName }}"
        - name: tmp
          emptyDir: {}
      container:
        image: "{{ workflow.parameters.imageSourceFetcherImageName }}"
        imagePullPolicy: Always
        command: ["/clusterscanner/entrypoint.bash"]
        volumeMounts:
          - name: "{{ workflow.parameters.gitSecretName }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
          - name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
            mountPath: /clusterscanner/image-source-list
          - name: tmp
            mountPath: /clusterscanner/out
        env:
          - name: GITHUB_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
        envFrom:
          - secretRef:
              name: "{{ workflow.parameters.gitSecretName }}"
          - configMapRef:
              name: "scanjob-env-parameter"

    - name: subflow
      inputs:
        artifacts:
          - name: imageList
            path: /clusterscanner/imageList.json
            mode: 0444
      container:
        image: "{{ workflow.parameters.workflowRunnerImageName }}"
        command: ["/clusterscanner/entrypoint.bash"]
        imagePullPolicy: Always
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
        env:
          - name: SCAN_ID
            value: "{{ workflow.parameters.scanId }}"
          - name: REGISTRY_SECRET
            value: "{{ workflow.parameters.registrySecretName }}"
          - name: DEPENDENCY_SCAN_CM
            value: "{{ workflow.parameters.dependencyCheckDbConfigMapName }}"
          - name: DEFECTDOJO_CM
            value: "{{ workflow.parameters.defectDojoConfigMapName }}"
          - name: DEFECTDOJO_SECRETS
            value: "{{ workflow.parameters.defectDojoConfigMapName }}"
          - name: MAX_RUNNING_JOBS_IN_QUEUE
            value: "4" # too many jobs create disk pressure
          - name: dependencyCheckSuppressionsConfigMapName
            value: "{{ workflow.parameters.dependencyCheckSuppressionsConfigMapName }}"
          - name: NEW_VERSION_IMAGE_FIILTER
            value: "{{ workflow.parameters.newVersionImageFilter }}"
          - name: baseImageName
            value: "{{ workflow.parameters.baseImageName }}"
          - name: defectDojoClientImageName
            value: "{{ workflow.parameters.defectDojoClientImageName }}"
          - name: scanDistrolessImageName
            value: "{{ workflow.parameters.scanDistrolessImageName }}"
          - name: scanDependencyCheckImageName
            value: "{{ workflow.parameters.scanDependencyCheckImageName }}"
          - name: scanMalwareImageName
            value: "{{ workflow.parameters.scanMalwareImageName }}"
          - name: scanRootImageName
            value: "{{ workflow.parameters.scanRootImageName }}"
          - name: scanLifetimeImageName
            value: "{{ workflow.parameters.scanLifetimeImageName }}"
          - name: scanNewVersionImageName
            value: "{{ workflow.parameters.scanNewVersionImageName }}"
          - name: notifierImageName
            value: "{{ workflow.parameters.notifierImageName }}"
          - name: scanSyftImageName
            value: "{{ workflow.parameters.scanSyftImageName }}"

    - name: notify-teams
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: cluster-image-scanner-scandata
      script:
        image: "{{ workflow.parameters.notifierImageName }}"
        volumeMounts:
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ workflow.parameters.scanId }}"
        imagePullPolicy: Always
        env:
          - name: SLACK_CLI_TOKEN
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.slackTokenSecretName }}"
                key: SLACK_CLI_TOKEN
          - name: ENFORCE_SLACK_CHANNEL
            value: "{{ workflow.parameters.enforceSlackChannel }}"
          - name: SCAN_NEW_VERSION_TOLERANCE_DAYS # time, in which the new version finding is in DefectDojo, but teams are not notified
            value: "4"
          - name: smtp
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp
          - name: smtp-auth
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth
          - name: smtp-auth-user
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth-user
          - name: smtp-auth-password
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth-password
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
        command: [/bin/bash]
        source: |
          #set -e
          shopt -s globstar nullglob

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi

          inform() {
            echo "image: ${image}, appName ${appName}, team: ${team}, namespace: ${namespace}, environment: ${environment}, ddLink: ${ddLink}, slackChannel: ${slack}, email: ${email}, scanType: ${scanType}, title: ${title}, info: ${infoText}, status: ${status}"

            #slack="#nobody-security" # for testing
            if [ "${slack}" != "" ]; then
              if [ "${SLACK_CLI_TOKEN}" == "" ]; then
                echo "SLACK_CLI_TOKEN not set, exit"
                exit 1
              fi
              echo "Sending to slack ${slack}"
              # shellcheck disable=SC2001
              info=$(echo "${info}" | sed 's#"##g'| sed 's|#||g' | sed 's|\n||g')
              ls -la /clusterscanner/
              cat /clusterscanner/slack-template.json | sed "s/###SLACK_CHANNEL###/${slack}/g" | sed "s#\#\#\#TITLE\#\#\##${title}#g"  > /tmp/slack-template.json
              sed -i "s|###STATUS###|${status}|g" /tmp/slack-template.json
              sed -i "s|###DD_LINK###|${ddLink}|g" /tmp/slack-template.json
              sed -i "s#\#\#\#IMAGE\#\#\##${image}#g" /tmp/slack-template.json
              sed -i "s#\#\#\#APP_NAME\#\#\##${appName}#g" /tmp/slack-template.json
              sed -i "s/###NAMESPACE###/${namespace}/g" /tmp/slack-template.json
              sed -i "s/###ENVIRONMENT###/${environment}/g" /tmp/slack-template.json 
              sed -i "s|###SEVERITY###|${severity}|g" /tmp/slack-template.json
              sed -i "s#_INFO_#${infoText}#g" /tmp/slack-template.json
              #awk -v r="${infoText}" '{gsub(/_INFO_/,r)}1' /tmp/slack-template.json
              echo "/tmp/slack-template.json:"
              cat /tmp/slack-template.json
            
              curl -H "Content-type: application/json" \
                -d @/tmp/slack-template.json \
                -H "Authorization: Bearer $SLACK_CLI_TOKEN"  \
                -X POST \
                "${SLACK_MESSAGE_ENDPOINT}"
            else
              echo "slackChannel not set"
            fi

            if [ "${email}" != "null" ] && [ "${email}" != "" ]; then
              echo "Sending to email ${email}"
              if [ "${smtp-auth-password}" != "YOURPASSWORD" ] && [ "${smtp-auth-password}" != "" ] && [ "${smtp-auth-password}" != "smtp_auth_password_SECRET" ]; then
                message="$message\nimage: ${image}, app: ${appName}, namespace: ${namespace}, environment: ${environment}, link to DefectDojo: ${ddLink}"
                echo -e "${message}" | mail -s "Found unhandled findings" "${email}" || echo "ERROR during sending ${message}"
              else
                echo "Warning: email set, but no email configured"
              fi
            else
              echo "Hint: email not set"
            fi
          }
          errors=""
          for file in "${RESULT_PATH}"/**/*.json; do
            echo "found file ${file}"
            item=$(cat "${file}")
            image=$(echo "${item}" | jq -r '.image'| tr -cd '[:alnum:]./@:_-')
            team=$(echo "${item}" | jq -r '.team'| tr -cd '[:alnum:]._-')
            namespace=$(echo "${item}" | jq -r '.namespace'| tr -cd '[:alnum:]._-')
            environment=$(echo "${item}" | jq -r '.environment'| tr -cd '[:alnum:]._-')
            slack=$(echo "${item}" | jq -r '.slack')
            appName=$(echo "${item}" | jq -r '.appname'| tr -cd '[:alnum:]._-')
            email=$(echo "${item}" | jq -r '.email')
            if [ "${ENFORCE_SLACK_CHANNEL}" != "" ]; then
              slack="${ENFORCE_SLACK_CHANNEL}"
            fi
            echo "Inspecting team ${team} for image ${image}"
            for result in $(echo "${item}" | jq -rcM '.uploadResults[] | @base64'); do
              for result2 in $(echo "${result}" | base64 -d | jq -rcM '.[] | @base64'); do
                notifications=$(echo "${result2}" | base64 -d | jq -rcM 'select(.finding == true)')
                while IFS= read -r notification; do
                  echo "in notification for ${image}"
                  ddLinkTest=$(echo "${notification}" | jq -r ".ddLink")
                  infoText=$(echo "${notification}" | jq -r ".infoText" | sed 's#{#(#g' | sed 's#}#)#g' | sed 's#"#_#g' | tr -cd '[:alnum:]._ \n:@*+()[]-')   # at least { } needs to be removed for the slack cli
                  echo "after ifo"
                  errorText=$(echo "${notification}" | jq -r ".errorText" | tr -cd '[:alnum:]._ \n:@*+()[]-' || true)
                  status=$(echo "${notification}" | jq -r ".status" | tr -cd '[:alnum:]._ -')
                  ddLinkScheme=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $1}')
                  ddLinkDomain=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $2}')
                  ddLinkBase="${ddLinkScheme}//${ddLinkDomain}"
                  for findingBase in $(echo "${notification}" | jq -rcM '.findings[] | @base64'); do
                    finding=$(echo "${findingBase}" | base64 -d)
                    findingId=$(echo "${finding}" | jq -r '.id' | tr -cd '[:alnum:]._ -')
                    if [ "${findingId}" != "null" ] && [ "${findingId}" != "" ]; then
                      ddLink="${ddLinkBase}/finding/${findingId}"
                    else
                      ddLink="${ddLinkTest}"
                    fi
                    title=$(echo "${finding}" | jq -r '.title' | cut -c1-50 | sed 's#{##g'| sed 's#}##g') #| tr -cd '[:alnum:]._ <>-')
                    if [ "$title" == "Image Has a New Version" ]; then
                      scanResultFindingFinishedAt=$(echo "${item}" | jq -r '.scanResults[]["scan-new-version"].cachedUsedAt' | grep -v null)
                      t1=$(date --date="${scanResultFindingFinishedAt}" +%s)

                      # Current date
                      dt2=$(date +%Y-%m-%d\ %H:%M:%S)
                      # Compute the seconds since epoch for date 2
                      t2=$(date --date="${dt2}" +%s)
                      # difference in dates in seconds
                      tDiff="$(( t2-t1 ))"
                      # hour difference
                      hDiff="$(( tDiff/3600 ))" || true
                      # day difference
                      dDiff="$(( hDiff/24 ))" || true
                      echo "t1: ${t1}, t2: ${t2}, dDiff: ${dDiff}"
                      if [ ${dDiff} -lt ${SCAN_NEW_VERSION_TOLERANCE_DAYS} ]; then
                        echo "${dDiff} is less than ${SCAN_NEW_VERSION_MAX_TOLERANCE_DAYS}, skipping notification of ${image} in ${namespace} on ${environment}"
                        continue
                      fi
                    fi
                    title="${title} in ${image}"
                    severity=$(echo "${finding}" | jq -r ".severity" | tr -cd '[:alnum:]._ -')
                    description=$(echo "${finding}" | jq -r '.description' | sed 's#{##g'| sed 's#}##g'  | tr -cd '[:alnum:]._ \n:@*+()[]-')
                    message="${infoText}; ${description}"
                    if [ "${errorText}" != "null" ] && [ "${errorText}" != "[]" ] && [ "${errorText}" != "" ]; then
                      message="${message}\nError: ${errorText}"
                    fi
                    output=$(inform "${image}" "${appName}" "${team}" "${namespace}" "${environment}" "${ddLink}" "${slack}" "${email}" "${title}" "${infoText}"  "${severity}" "${status}" || true)
                    echo "${output}"
                    if [ "$(echo "${output}" | grep -c '"ok": false')" -gt 0 ]; then
                      echo "error in slack"
                      errors="${errors}\n${output}"
                    fi
                    if [ "$(echo "${output}" | grep -c ratelimited)" -gt 0 ]; then
                      sleep 120 # wait for rate limt
                      inform "${image}" "${appName}" "${team}" "${namespace}" "${environment}" "${ddLink}" "${slack}" "${email}" "${title}" "${message}"
                    fi
                    sleep 1 # reduce risk of rate limit
                  done
                done <<< "${notifications}"
              done
            done
          done
          echo "${errors}"

    - name: git-upload-report
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: cluster-image-scanner-scandata
        - name: "{{ workflow.parameters.gitSecretName }}"
          secret:
            secretName: "{{ workflow.parameters.gitSecretName }}"
      script:
        image: "{{ workflow.parameters.imageCollectorImageName }}"
        volumeMounts:
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ workflow.parameters.scanId }}"
          - name: "{{ workflow.parameters.gitSecretName }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
        imagePullPolicy: IfNotPresent
        env:
          - name: ENVIRNOMENT
            value: "{{ workflow.parameters.scanId }}"
          - name: SCAN_ID
            value: "{{ workflow.parameters.scanId }}"
          - name: GITHUB_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
          - name: GITHUB_REPOSITORY
            value: "{{ workflow.parameters.allResultsGitTarget }}"
          - name: WORKFLOW_DATE
            value: "{{ workflow.creationTimestamp.Y }}{{ workflow.creationTimestamp.m }}{{ workflow.creationTimestamp.d }}"
        envFrom:
          - secretRef:
              name: "{{ workflow.parameters.gitSecretName }}"
          - configMapRef:
              name: "scanjob-env-parameter"
        command: [/bin/bash]
        source: |
          set -e
          cd $HOME
          source auth.bash # > /dev/null 2>&1
          source git.bash # > /dev/null 2>&1

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi
          
          if [ "${GITHUB_REPOSITORY}" == "" ]; then
            echo "No repo to upload stats"
            exit 0
          fi

          gitAuth
          echo "gitFetch"
          gitFetch


          tmpdir=$(mktemp -d)
          tmpdirBaseImage=$(mktemp -d)
          mkdir /tmp/clusterscanner-remote/${WORKFLOW_DATE} || true
          # echo "tmpdir: ${tmpdir}, tmpdirBaseImage: ${tmpdirBaseImage}"
          echo "${RESULT_PATH}"
          ls -la "${RESULT_PATH}" 
          for result in $(find ${RESULT_PATH} -name *.json); do
            team=$(cat $result | jq -r '.team' | sed 's/\s//g' || true)
            age=$(cat $result | jq -r '.scanResults[] | .["scan-lifetime"].age' | grep -v null || true)
            baseImageAge=$(cat $result | jq -r '.scanResults[] | .["scan-baseimage-lifetime"].age' | grep -v null || true)
            environment=$(cat $result | jq -r '.environment' | sed 's/\s//g' || true)
            image=$(cat $result | jq -r '.image' | sed 's/\s//g' || true)
            reproducibleBuildImage="false"
            reproducibleBuildBaseImage="false"
            for keyBase64 in $(cat $result | jq -r '.scanResults[]  | @base64'); do
              key=$(echo ${keyBase64} | base64 -d)
              if [ "$(echo $key | jq '. | has("scan-lifetime")')" == "true" ] && [ "$(echo "${key}" | jq -r '.["scan-lifetime"] | has("reproducibleBuild")')" == "true" ]; then
                echo "scan-lifetime found"
                reproducibleBuildImage=$(echo ${key} | jq -r '.["scan-lifetime"].reproducibleBuild' | grep -v null)
              else
                echo "scan-lifetime not found"
              fi
              if [ "$(echo ${key} | jq '. | has("scan-baseimage-lifetime")')" == "true"  ] && [ "$(echo "${key}" | jq -r '.["scan-baseimage-lifetime"] | has("reproducibleBuild")')" == "true" ] ; then
                echo "scan-baseimage-lifetime found"
                reproducibleBuildBaseImage=$(echo ${key} | jq -r '.["scan-baseimage-lifetime"].reproducibleBuild' | grep -v null)
              else
                echo "scan-baseimage-lifetime not found"
              fi
            done
            
            if [ "${age}" != "" ]; then
              if [ "${reproducibleBuildImage}" == "true" ]; then
                echo "Skipping age for ${image} due to reproducibleBuildImage"
                echo "${image} ${age}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${environment}_invalid_creation_date_image-lifetime_${team}.txt
              else
                echo ${age} >> ${tmpdir}/${environment}_${team}.txt
              fi
            fi
            if [ "${baseImageAge}" != "" ]; then
              if [ "${reproducibleBuildBaseImage}" == "true" ]; then
                echo "Skipping baseImageAge for ${image} due to reproducibleBuildImage"
                echo "${image} ${baseImageAge}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${environment}_invalid_creation_date_baseimage-lifetime_$${team}.txt
              else
                echo ${baseImageAge} >> ${tmpdirBaseImage}/${environment}_${team}.txt
              fi          
            fi
          done
          echo "${tmpdir}"
          ls -la "${tmpdir}"
          
          for j in $(ls ${tmpdir}); do
            result=$(cat ${tmpdir}/${j}  | awk '{if(min==""){min=max=$1}; if($1>max) {max=$1}; if($1<min) {min=$1}; total+=$1; count+=1} END {print total/count, max, min}')
            filename=$(echo ${j} | sed 's#.txt##g')
            echo "lifetime for images is (avg max min) ${result}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${filename}_lifetime.txt
            echo "${result} ${filename}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv
          done
          cat /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv | sort -n >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview-tmp.csv
          mv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview-tmp.csv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv

          for j in $(ls ${tmpdirBaseImage}); do
            result=$(cat ${tmpdirBaseImage}/${j}  | awk '{if(min==""){min=max=$1}; if($1>max) {max=$1}; if($1<min) {min=$1}; total+=$1; count+=1} END {print total/count, max, min}')
            filename=$(echo ${j} | sed 's#.txt##g')
            echo "baseimage lifetime for images is (avg max min) ${result}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${filename}_baseimage-lifetime.txt
            echo " ${result} ${filename}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv
          done
          cat /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv | sort -n >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview-tmp.csv
          mv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview-tmp.csv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv 
          
          echo "Start (SCAN_ID): ${SCAN_ID}, end: $(date)" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/infos.txt
          
          cd /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          ls -la /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          git add * || true
          git commit -m "add" || true

          git push -f origin master || true


