apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: orchestration-job-template
  namespace: argowf
spec:
  onExit: exit-handler
  activeDeadlineSeconds: 21600 # 6h
  entrypoint: main # Entry point for job execution
  workflowSpec:
    #serviceAccountName: clusterscanner
    ttlStrategy:
      secondsAfterSuccess: 7200 # 2 hours
      secondsAfterFailure: 86400 # 1 day
    artifactRepositoryRef:
      configMap: artifact-repositories
      key: default-v1
  inputs:
    parameters:
      - workflow.parameters.imageSourceListConfigMapName
      - workflow.parameters.gitSecretName
      - workflow.parameters.s3SecretName
      - workflow.parameters.s3ConfigName
      - workflow.parameters.scanId
      - workflow.parameters.registrySecretName
      - workflow.parameters.dependencyCheckDbConfigMapName
      - workflow.parameters.defectDojoConfigMapName
      - workflow.parameters.slackTokenSecretName
      - workflow.parameters.emailSecretName
      - workflow.parameters.enforceSlackChannel
      - workflow.parameters.newVersionImageFilter
      - workflow.parameters.dependencyCheckSuppressionsConfigMapName
      - workflow.parameters.allResultsGitTarget
      - workflow.parameters.imageRegistryBase
      - workflow.parameters.clusterImageScannerImageTag
      - workflow.parameters.errorTargets

  templates:
    - name: main
      steps:
        - - name: fetch-image-list
            template: fetch-image-list
        - - name: run-subflow
            template: subflow
            arguments:
              artifacts:
                - name: imageList
                  from: "{{steps.fetch-image-list.outputs.artifacts.image-list-merged}}"
        - - name: notify-teams
            template: notify-teams
        - - name: generate-lifetime-statistics
            template: generate-lifetime-statistics
    #            when: "{{ workflow.parameters.allResultsGitTarget }} == "
        - - name: generate-response-statistics
            template: generate-response-statistics
        - - name: git-upload-response-statistics
            template: git-upload-response-statistics
            arguments:
              artifacts:
                - name: team-statistics
                  from: "{{steps.generate-response-statistics.outputs.artifacts.team-statistics}}"
        - - name: cleanup-dependency-track
            template: cleanup-dependency-track

    - name: fetch-image-list
      outputs:
        artifacts:
          - name: image-lists
            path: /clusterscanner/out
            archive:
              none: {}
          - name: image-list-merged
            path: /clusterscanner/out/merged/merged.json
            archive:
              none: {}
      volumes:
        - name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
          configMap:
            name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
        - name: "{{ workflow.parameters.gitSecretName }}"
          secret:
            secretName: "{{ workflow.parameters.gitSecretName }}"
        - name: out
          emptyDir: {}
        - name: tmp
          emptyDir: {}
      container:
        image: "{{ workflow.parameters.imageRegistryBase }}/cluster-image-scanner-image-source-fetcher:{{ workflow.parameters.clusterImageScannerImageTag }}"
        imagePullPolicy: Always
        command: ["/clusterscanner/entrypoint.bash"]
        resources:
          limits:
            cpu: '1'
            memory: 256Mi
          requests:
            cpu: '1'
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: false # .gitignore needs to be locked
          runAsNonRoot: true
          runAsUser: 1001
        volumeMounts:
          - name: "{{ workflow.parameters.gitSecretName }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
          - name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
            mountPath: /clusterscanner/image-source-list
          - name: tmp
            mountPath: /tmp
          - name: out
            mountPath: /clusterscanner/out
        env:
          - name: GH_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
        envFrom:
          - secretRef:
              name: "{{ workflow.parameters.gitSecretName }}"
          - secretRef:
              name: "{{ workflow.parameters.s3SecretName }}"
          - configMapRef:
              name: "scanjob-env-parameter"
          - configMapRef:
              name: "{{ workflow.parameters.s3ConfigName }}"

    - name: subflow
      volumes:
        - name: tmp
          emptyDir: {}
      inputs:
        artifacts:
          - name: imageList
            path: /clusterscanner/imageList.json
            mode: 0444
      container:
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        resources:
          limits:
            cpu: '1'
            memory: 256Mi
          requests:
            cpu: '0.2'
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
        image: "{{ workflow.parameters.imageRegistryBase }}/cluster-image-scanner-workflow-runner:{{ workflow.parameters.clusterImageScannerImageTag }}"
        command: ["/clusterscanner/entrypoint.bash"]
        imagePullPolicy: Always
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
        env:
          - name: SCAN_ID
            value: "{{ workflow.parameters.scanId }}"
          - name: REGISTRY_SECRET
            value: "{{ workflow.parameters.registrySecretName }}"
          - name: DEPENDENCY_SCAN_CM
            value: "{{ workflow.parameters.dependencyCheckDbConfigMapName }}"
          - name: DEFECTDOJO_CM
            value: "{{ workflow.parameters.defectDojoConfigMapName }}"
          - name: DEFECTDOJO_SECRETS
            value: "{{ workflow.parameters.defectDojoConfigMapName }}"
          - name: dependencyCheckSuppressionsConfigMapName
            value: "{{ workflow.parameters.dependencyCheckSuppressionsConfigMapName }}"
          - name: imageRegistryBase
            value: "{{ workflow.parameters.imageRegistryBase }}"
          - name: clusterImageScannerImageTag
            value: "{{ workflow.parameters.clusterImageScannerImageTag }}"
          - name: "slackTokenSecretName"
            value: "{{ workflow.parameters.slackTokenSecretName }}"
          - name: errorTargets
            value: "{{ workflow.parameters.errorTargets }}"
          - name: IS_PRINT_TEMPLATE
            value: "true" # TODO false

    - name: notify-teams
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: cluster-image-scanner-scandata
        - name: tmp
          emptyDir: {}
      script:
        resources:
          limits:
            cpu: '1'
            memory: 768Mi
          requests:
            cpu: '0.2'
            memory: 768Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
        image: "{{ workflow.parameters.imageRegistryBase }}/cluster-image-scanner-notifier:{{ workflow.parameters.clusterImageScannerImageTag }}" # has mailx
        volumeMounts:
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ workflow.parameters.scanId }}"
          - name: tmp
            mountPath: /tmp
        imagePullPolicy: Always
        env:
          - name: SLACK_CLI_TOKEN
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.slackTokenSecretName }}"
                key: SLACK_CLI_TOKEN
          - name: ENFORCE_SLACK_CHANNEL
            value: "{{ workflow.parameters.enforceSlackChannel }}"
          - name: SCAN_NEW_VERSION_TOLERANCE_DAYS # time, in which the new version finding is in DefectDojo, but teams are not notified
            value: "4"
          - name: smtp
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp
          - name: smtp-auth
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth
          - name: smtp-auth-user
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth-user
          - name: smtpauthpassword # because - are not allowed in bash variable names
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth-password
          - name: smtp-auth-password
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth-password
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
        command: [/bin/bash]
        source: |
          set -e
          shopt -s globstar nullglob

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi

          inform() {
            echo "image: ${image}, appName ${appName}, team: ${team}, namespace: ${namespace}, environment: ${environment}, ddLink: ${ddLink}, slackChannel: ${slack}, rocketchat: ${rocketchat}, email: ${email}, scanType: ${scanType}, title: ${title}, info: ${infoText}, status: ${status}"
            #slack="#nobody-security" # for testing
            if [ "${rocketchat}" == "null" ]; then rocketchat=""; fi
            if [ "${slack}" == "null" ]; then slack=""; fi
            if [ "${slack}" != "" ] || [ "${rocketchat}" != "" ]; then
              # shellcheck disable=SC2001
              info=$(echo "${infoText}" | sed 's#"##g'| sed 's|#||g' | sed 's|\n||g')
              infoNoNewline=$(echo ${info} | sed 's#"##g'| sed 's|#||g' | sed 's|\n|; |g')
              echo "${SLACK_TEMPLATE}" | sed "s/###SLACK_CHANNEL###/${slack}/g" | sed "s/###ROCKETCHAT_CHANNEL###/${rocketchat}/g" | sed "s#\#\#\#TITLE\#\#\##${title}#g"  > /tmp/slack-template.json
              sed -i "s|###STATUS###|${status}|g" /tmp/slack-template.json
              sed -i "s|###DD_LINK###|${ddLink}|g" /tmp/slack-template.json
              sed -i "s#\#\#\#IMAGE\#\#\##${image}#g" /tmp/slack-template.json
              sed -i "s#\#\#\#APP_NAME\#\#\##${appName}#g" /tmp/slack-template.json
              sed -i "s/###NAMESPACE###/${namespace}/g" /tmp/slack-template.json
              sed -i "s/###ENVIRONMENT###/${environment}/g" /tmp/slack-template.json 
              sed -i "s|###SEVERITY###|${severity}|g" /tmp/slack-template.json
              sed -i "s#_INFO_#${infoNoNewline}#g" /tmp/slack-template.json
              #echo "/tmp/slack-template.json:"
              #cat /tmp/slack-template.json
              if [ "${slack}" != "" ]; then
                if [ "${SLACK_CLI_TOKEN}" == "" ]; then
                  echo "SLACK_CLI_TOKEN not set, exit"
                  exit 1
                fi
                echo "Sending to slack ${slack} with messageendpoint ${SLACK_MESSAGE_ENDPOINT}"
                curl \
                  -H "Content-type:application/json" \
                  -H "Authorization: Bearer ${SLACK_CLI_TOKEN}" \
                  -X POST \
                  -d @/tmp/slack-template.json \
                  "${SLACK_MESSAGE_ENDPOINT}"
              else
                echo "Slack not configured in collector"          
              fi
              if [ "${rocketchat}" != "" ]; then
                if [ "${ROCKET_CHAT_USER_ID}" == "" ]; then # ROCKET_CHAT_USER_ID comes from cm scanjob-parameter
                  echo "No ROCKET_CHAT_USER_ID set"
                fi
                if [ "${SLACK_CLI_TOKEN}" == "" ]; then
                  echo "No SLACK_CLI_TOKEN set"
                fi          
                echo "Sending to rocketchat ${SLACK_MESSAGE_ENDPOINT} ${rocketchat}"
                curl -H "Content-type: application/json" \
                  -d @/tmp/slack-template.json \
                  -H "X-Auth-Token: ${SLACK_CLI_TOKEN}" \
                  -H "X-User-Id: ${ROCKET_CHAT_USER_ID}" \
                  -X POST \
                  "${SLACK_MESSAGE_ENDPOINT}"
              else
                echo "rocketchat not configured in collector"          
              fi
            fi
            if [ "${email}" != "null" ] && [ "${email}" != "" ]; then
              if [ "${smtpauthpassword}" != "YOURPASSWORD" ] && [ "${smtpauthpassword}" != "" ] && [ "${smtpauthpassword}" != "smtp_auth_password_SECRET" ]; then
                echo "Sending to email ${email}"
                message="$message\nimage: ${image}, app: ${appName}, namespace: ${namespace}, environment: ${environment}, link to DefectDojo: ${ddLink}"
                echo -e "${message}" | mail -s "Found unhandled findings" "${email}" || echo "ERROR during sending ${message}"
              else
                echo "Warning: email set, but no email configured"
              fi
            else
              echo "Hint: email not set"
            fi
          }
          errors=""
          echo "Will iterate over files in ${RESULT_PATH}"
          for file in "${RESULT_PATH}"/**/*.json; do
            echo "found file ${file}"
            item=$(cat "${file}")
            image=$(echo "${item}" | jq -r '.image'| tr -cd '[:alnum:]./@:_-')
            team=$(echo "${item}" | jq -r '.team'| tr -cd '[:alnum:]._-')
            namespace=$(echo "${item}" | jq -r '.namespace'| tr -cd '[:alnum:]._-')
            environment=$(echo "${item}" | jq -r '.environment'| tr -cd '[:alnum:]._-')
            slack=$(echo "${item}" | jq -r '.slack')
            rocketchat=$(echo "${item}" | jq -r '.rocketchat')
            appName=$(echo "${item}" | jq -r '.appname'| tr -cd '[:alnum:]._-')
            email=$(echo "${item}" | jq -r '.email')
            if [ "${ENFORCE_SLACK_CHANNEL}" != "" ]; then
              slack="${ENFORCE_SLACK_CHANNEL}"
            fi
            echo "Inspecting team ${team} for image ${image}"
            for result in $(echo "${item}" | jq -rcM '.uploadResults[] | @base64'); do
              for result2 in $(echo "${result}" | base64 -d | jq -rcM '.[] | @base64'); do
                notifications=$(echo "${result2}" | base64 -d | jq -rcM 'select(.finding == true)')
                while IFS= read -r notification; do
                  echo "in notification for ${image}"
                  ddLinkTest=$(echo "${notification}" | jq -r ".ddLink")
                  echo "after defining ddLinkTest"
                  echo "${notification}" | jq -r ".infoText"
                  infoText=$(echo "${notification}" | jq -r ".infoText" | sed 's#{#(#g' | sed 's#}#)#g' | sed 's#"#_#g' | tr -cd '[:alnum:]._ \n:@*+()[]-')   # at least { } needs to be removed for the slack cli
                  echo "after defining info"
                  errorText=$(echo "${notification}" | jq -r ".errorText" | tr -cd '[:alnum:]._ \n:@*+()[]-' || true)
                  status=$(echo "${notification}" | jq -r ".status" | tr -cd '[:alnum:]._ -')
                  ddLinkScheme=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $1}')
                  ddLinkDomain=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $2}')
                  ddLinkBase="${ddLinkScheme}//${ddLinkDomain}"
                  for findingBase in $(echo "${notification}" | jq -rcM '.findings[] | @base64'); do
                    echo "In findingBase for ${image}"
                    finding=$(echo "${findingBase}" | base64 -d)
                    findingId=$(echo "${finding}" | jq -r '.id' | tr -cd '[:alnum:]._ -')
                    if [ "${findingId}" != "null" ] && [ "${findingId}" != "" ]; then
                      ddLink="${ddLinkBase}/finding/${findingId}"
                    else
                      ddLink="${ddLinkTest}"
                    fi
                    echo "findingId ${findingId}"
                    title=$(echo "${finding}" | jq -r '.title' | cut -c1-50 | sed 's#{##g'| sed 's#}##g') #| tr -cd '[:alnum:]._ <>-')
                                        if [ "$title" == "Image Has a New Version" ]; then
                                          echo "In new version, skipping. In a later version, we will inform after X days"
                                          continue;
                                          
                    #                      echo "item: ${item}"
                    #                      scanResultFindingFinishedAt=$(echo "${item}" | jq -r '.scanResults[]["scan-new-version"].cachedUsedAt' | grep -v null) # doesn't work
                    #                      echo "scanResultFindingFinishedAt ${scanResultFindingFinishedAt}"
                    #                      t1=$(date --date="${scanResultFindingFinishedAt}" +%s)
                    #                      # Current date
                    #                      dt2=$(date +%Y-%m-%d\ %H:%M:%S)
                    #                      # Compute the seconds since epoch for date 2
                    #                      t2=$(date --date="${dt2}" +%s)
                    #                      # difference in dates in seconds
                    #                      tDiff="$(( t2-t1 ))"
                    #                      # hour difference
                    #                      hDiff="$(( tDiff/3600 ))" || true
                    #                      # day difference
                    #                      dDiff="$(( hDiff/24 ))" || true
                    #                      echo "t1: ${t1}, t2: ${t2}, dDiff: ${dDiff}"
                    #                      if [ ${dDiff} -lt ${SCAN_NEW_VERSION_TOLERANCE_DAYS} ]; then
                    #                        echo "${dDiff} is less than ${SCAN_NEW_VERSION_MAX_TOLERANCE_DAYS}, skipping notification of ${image} in ${namespace} on ${environment}"
                    #                        continue
                    #                      fi
                                        fi
                    title="${title} in ${image}"
                    echo "${title} in ${image}"
                    severity=$(echo "${finding}" | jq -r ".severity" | tr -cd '[:alnum:]._ -')
                    description=$(echo "${finding}" | jq -r '.description' | sed 's#{##g'| sed 's#}##g'  | tr -cd '[:alnum:]._ \n:@*+()[]-' | sed 's|#||g')
                    message="${infoText}; ${description}"
                    echo "created message, will create error if exists"
                    if [ "${errorText}" != "null" ] && [ "${errorText}" != "[]" ] && [ "${errorText}" != "" ]; then
                      message="${message}\nError: ${errorText}"
                      infoText="${infoText}; Error: ${errorText}"
                    fi
                    echo "will inform ${image}"
                    inform 
                    sleep 1 # reduce risk of rate limit
                  done
                done <<< "${notifications}"
              done
            done
          done
          echo "${errors}"

    - name: generate-lifetime-statistics
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: cluster-image-scanner-scandata
        - name: tmp
          emptyDir: {}
        - name: "{{ workflow.parameters.gitSecretName }}"
          secret:
            secretName: "{{ workflow.parameters.gitSecretName }}"
      script:
        resources:
          limits:
            cpu: '1'
            memory: 256Mi
          requests:
            cpu: '0.2'
            memory: 64Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: false # .gitignore needs to be locked
          runAsNonRoot: true
          runAsUser: 1001
        image: "{{ workflow.parameters.imageRegistryBase }}/cluster-image-scanner-imagecollector:{{ workflow.parameters.clusterImageScannerImageTag }}"
        volumeMounts:
          - name: tmp
            mountPath: /tmp
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ workflow.parameters.scanId }}"
          - name: "{{ workflow.parameters.gitSecretName }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
        imagePullPolicy: IfNotPresent
        env:
          - name: ENVIRNOMENT
            value: "{{ workflow.parameters.scanId }}"
          - name: SCAN_ID
            value: "{{ workflow.parameters.scanId }}"
          - name: GH_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
          - name: GIT_REPOSITORY
            value: "{{ workflow.parameters.allResultsGitTarget }}"
          - name: WORKFLOW_DATE
            value: "{{ workflow.creationTimestamp.Y }}{{ workflow.creationTimestamp.m }}{{ workflow.creationTimestamp.d }}"
        envFrom:
          - secretRef:
              name: "{{ workflow.parameters.gitSecretName }}"
          - configMapRef:
              name: "scanjob-env-parameter"
        command: [/bin/bash]
        source: |
          set -e
          cd $HOME
                  
          source auth.bash # > /dev/null 2>&1
          source git.bash # > /dev/null 2>&1

          if [ "${GIT_SSH_REPOSITORY_HOST}" == "SET-ME" ] && [ "${GH_INSTALLATION_ID}" == "" ]; then
            echo "GIT_SSH_REPOSITORY_HOST and GH_INSTALLATION_ID not configured, skipping"
            exit 0
          fi
          echo "GIT_REPOSITORY $GIT_REPOSITORY"

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi
          
          if [ "${GIT_REPOSITORY}" == "" ]; then
            echo "No repo to upload stats"
            exit 0
          fi

          gitAuth
          echo "gitFetch"
          gitFetch


          tmpdir=$(mktemp -d)
          tmpdirBaseImage=$(mktemp -d)
          mkdir /tmp/clusterscanner-remote/${WORKFLOW_DATE} || true
          # echo "tmpdir: ${tmpdir}, tmpdirBaseImage: ${tmpdirBaseImage}"
          echo "${RESULT_PATH}"
          ls -la "${RESULT_PATH}" 
          for result in $(find ${RESULT_PATH} -name *.json); do
            team=$(cat $result | jq -r '.team' | sed 's/\s//g' || true)
            age=$(cat $result | jq -r '.scanResults[] | .["scan-lifetime"].age' | grep -v null || true)
            baseImageAge=$(cat $result | jq -r '.scanResults[] | .["scan-baseimage-lifetime"].age' | grep -v null || true)
            environment=$(cat $result | jq -r '.environment' | sed 's/\s//g' || true)
            image=$(cat $result | jq -r '.image' | sed 's/\s//g' || true)
            reproducibleBuildImage="false"
            reproducibleBuildBaseImage="false"
            for keyBase64 in $(cat $result | jq -r '.scanResults[]  | @base64'); do
              key=$(echo ${keyBase64} | base64 -d)
              if [ "$(echo $key | jq '. | has("scan-lifetime")')" == "true" ] && [ "$(echo "${key}" | jq -r '.["scan-lifetime"] | has("reproducibleBuild")')" == "true" ]; then
                echo "scan-lifetime found"
                reproducibleBuildImage=$(echo ${key} | jq -r '.["scan-lifetime"].reproducibleBuild' | grep -v null)
              else
                echo "scan-lifetime not found"
              fi
              if [ "$(echo ${key} | jq '. | has("scan-baseimage-lifetime")')" == "true"  ] && [ "$(echo "${key}" | jq -r '.["scan-baseimage-lifetime"] | has("reproducibleBuild")')" == "true" ] ; then
                echo "scan-baseimage-lifetime found"
                reproducibleBuildBaseImage=$(echo ${key} | jq -r '.["scan-baseimage-lifetime"].reproducibleBuild' | grep -v null)
              else
                echo "scan-baseimage-lifetime not found"
              fi
            done
            
            if [ "${age}" != "" ]; then
              if [ "${reproducibleBuildImage}" == "true" ]; then
                echo "Skipping age for ${image} due to reproducibleBuildImage"
                echo "${image} ${age}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${environment}_invalid_creation_date_image-lifetime_${team}.txt
              else
                echo ${age} >> ${tmpdir}/${environment}_${team}.txt
              fi
            fi
            if [ "${baseImageAge}" != "" ]; then
              if [ "${reproducibleBuildBaseImage}" == "true" ]; then
                echo "Skipping baseImageAge for ${image} due to reproducibleBuildImage"
                echo "${image} ${baseImageAge}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${environment}_invalid_creation_date_baseimage-lifetime_$${team}.txt
              else
                echo ${baseImageAge} >> ${tmpdirBaseImage}/${environment}_${team}.txt
              fi          
            fi
          done
          echo "${tmpdir}"
          ls -la "${tmpdir}"
          
          for j in $(ls ${tmpdir}); do
            result=$(cat ${tmpdir}/${j}  | awk '{if(min==""){min=max=$1}; if($1>max) {max=$1}; if($1<min) {min=$1}; total+=$1; count+=1} END {print total/count, max, min}')
            filename=$(echo ${j} | sed 's#.txt##g')
            echo "lifetime for images is (avg max min) ${result}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${filename}_lifetime.txt
            echo "${result} ${filename}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv
          done
          cat /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv | sort -n >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview-tmp.csv
          mv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview-tmp.csv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv

          for j in $(ls ${tmpdirBaseImage}); do
            result=$(cat ${tmpdirBaseImage}/${j}  | awk '{if(min==""){min=max=$1}; if($1>max) {max=$1}; if($1<min) {min=$1}; total+=$1; count+=1} END {print total/count, max, min}')
            filename=$(echo ${j} | sed 's#.txt##g')
            echo "baseimage lifetime for images is (avg max min) ${result}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${filename}_baseimage-lifetime.txt
            echo " ${result} ${filename}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv
          done
          cat /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv | sort -n >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview-tmp.csv
          mv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview-tmp.csv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv 
          
          echo "Start (SCAN_ID): ${SCAN_ID}, end: $(date)" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/infos.txt
          
          cd /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          ls -la /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          git add * || true
          git commit -m "add" || true

          git push -f origin master || true


    - name: generate-response-statistics
      outputs:
        artifacts:
          - name: team-statistics
            path: /tmp/team-response-statistics.csv
      volumes:
        - name: tmp
          emptyDir: { }
      container:
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        resources:
          limits:
            cpu: '1'
            memory: 768Mi
          requests:
            cpu: '0.2'
            memory: 512Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
        image: "{{ workflow.parameters.imageRegistryBase }}/defectdojo-statistic-client:3"
        imagePullPolicy: Always # TODO IfNotPresent
        command: [ "java", "-cp", "@/app/jib-classpath-file", "org.sdase.Main" ]
        envFrom:
          - configMapRef:
              name: "{{ workflow.parameters.defectDojoConfigMapName }}"
          - configMapRef:
              name: "scanjob-env-parameter"
          - secretRef:
              name: "{{ workflow.parameters.defectDojoConfigMapName }}"

    - name: git-upload-response-statistics
      volumes:
        - name: "{{ workflow.parameters.gitSecretName }}"
          secret:
            secretName: "{{ workflow.parameters.gitSecretName }}"
        - name: tmp
          emptyDir: {}
      inputs:
        artifacts:
          - name: team-statistics
            path: /tmp/team-response-statistics.csv
      script:
        resources:
          limits:
            cpu: '1'
            memory: 256Mi
          requests:
            cpu: '0.2'
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: false
          runAsNonRoot: true
          runAsUser: 1001
        image: "{{ workflow.parameters.imageRegistryBase }}/cluster-image-scanner-imagecollector:{{ workflow.parameters.clusterImageScannerImageTag }}"
        volumeMounts:
          - name: "{{ workflow.parameters.gitSecretName }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
          - name: tmp
            mountPath: /tmp
        imagePullPolicy: IfNotPresent
        env:
          - name: SCAN_ID
            value: "{{ workflow.parameters.scanId }}"
          - name: GH_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
          - name: GIT_REPOSITORY
            value: "{{ workflow.parameters.allResultsGitTarget }}"
          - name: WORKFLOW_DATE
            value: "{{ workflow.creationTimestamp.Y }}{{ workflow.creationTimestamp.m }}{{ workflow.creationTimestamp.d }}"
        envFrom:
          - secretRef:
              name: "{{ workflow.parameters.gitSecretName }}"
          - configMapRef:
              name: "scanjob-env-parameter"
        command: [/bin/bash]
        source: |
          set -e
          cd $HOME
          
          source auth.bash # > /dev/null 2>&1
          source git.bash # > /dev/null 2>&1

          if [ "${GIT_SSH_REPOSITORY_HOST}" == "SET-ME" ] && [ "${GH_INSTALLATION_ID}" == "" ]; then
            echo "GIT_SSH_REPOSITORY_HOST and GH_INSTALLATION_ID not configured, skipping"
            exit 0
          fi

          if [ "${GIT_REPOSITORY}" == "" ]; then
            echo "No repo to upload stats"
            exit 0
          fi

          gitAuth
          echo "gitFetch"
          gitFetch

          mkdir /tmp/clusterscanner-remote/${WORKFLOW_DATE} || true
          cat /tmp/team-response-statistics.csv >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/team-response-statistics.csv
          cd /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          ls -la /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          
          git add * || true
          git commit -m "add response statistics" || true

          git push -f origin master || true
          

    - name: cleanup-dependency-track
      volumes:
        - name: tmp
          emptyDir: { }
      script:
        resources:
          limits:
            cpu: '1'
            memory: 256Mi
          requests:
            cpu: '0.2'
            memory: 64Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
        image: "{{ workflow.parameters.imageRegistryBase }}/cluster-image-scanner-base:{{ workflow.parameters.clusterImageScannerImageTag }}"
        command: [/bin/bash]
        imagePullPolicy: IfNotPresent
        envFrom:
          - secretRef:
              name: "dependency-track"
          - configMapRef:
              name: "scanjob-env-parameter"
          - configMapRef:
              name: "dependency-track"
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        source: |
          if [ "${DEPENDENCY_TRACK_DAYS_TO_KEEP_PROJECT_WITHOUT_UPLOAD}" == "0" ]; then
            echo "DEPENDENCY_TRACK_DAYS_TO_KEEP_PROJECT_WITHOUT_UPLOAD is set 0, exit"
            exit 0
          fi
          if [ "${DEPENDENCY_TRACK_URL}" == "" ]; then
            echo "DEPENDENCY_TRACK_URL is empty, exit"
            exit 0
          fi
          now=$(date +"%s");
          oneDayInSec=86400;
          maxAge=$(($now-$oneDayInSec*${DEPENDENCY_TRACK_DAYS_TO_KEEP_PROJECT_WITHOUT_UPLOAD}));
          echo "maxAge: ${maxAge}"
          # TODO: Paging in case this uses up to much RAM
          content=$(curl "${DEPENDENCY_TRACK_URL}/api/v1/project?excludeInactive=true&=" \
            --silent \
            --show-error \
            --header 'Accept: application/json' \
            -H "X-API-Key: ${DEPENDENCY_TRACK_KEY}")
          echo $content | jq -r ".[] | select(.lastBomImport > ${maxAge}) | .uuid" > /tmp/projects-to-set-inactive
          
          for uuid in $(cat /tmp/projects-to-set-inactive); do
            echo "UUID $uuid"
            name=$(curl  \
              -H 'Content-Type: application/json' \
              -H "X-API-Key: ${DEPENDENCY_TRACK_KEY}" \
              --silent \
              --show-error \
            "${DEPENDENCY_TRACK_URL}/api/v1/project/${uuid}" | jq '.name')
            nameParameterUrlEncoded=$(printf %s "${name}" | jq -sRr @uri)
            echo '{ "name": "'${nameParameterUrlEncoded}'", "uuid": "'${uuid}'", "active": false}' > /tmp/tmpfile
            echo "After a test period, we will set ${nameParameterUrlEncoded} with UUID ${uuid} to active=false"
            #curl -X "PUT" \
            #  -H 'Content-Type: application/json' \
            #  -H "X-API-Key: ${DEPENDENCY_TRACK_KEY}" \
            #  -d @/tmp/tmpfile \
            #  --silent \
            #  --show-error \
            #  "${DEPENDENCY_TRACK_URL}/api/v1/project"
          done

    - name: exit-handler
      volumes:
        - name: tmp
          emptyDir: { }
      script:
        command: [/bin/bash]
        resources:
          limits:
            cpu: '1'
            memory: 128Mi
          requests:
            cpu: '0.2'
            memory: 128Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
        image: "{{ workflow.parameters.imageRegistryBase }}/cluster-image-scanner-base:{{ workflow.parameters.clusterImageScannerImageTag }}"
        imagePullPolicy: Always # TODO IfNotPresent
        env: # TODO check for email creds
          - name: MESSAGE_TARGETS
            value: "{{ workflow.parameters.errorTargets }}"
          - name: SLACK_CLI_TOKEN
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.slackTokenSecretName }}"
                key: SLACK_CLI_TOKEN
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        source: |
          if [ "${MESSAGE_TARGETS}" == "" ]; then
            echo "MESSAGE_TARGETS set, exiting"
            exit 1
          fi
          if [ "${JOB_EXECUTION_NAMESPACE}" == "" ]; then # comming from scanjob-parameter
            JOB_EXECUTION_NAMESPACE="clusterscanner"
          fi
          failures='{{workflow.failures}}'
          failures=$(echo "${failures:1:-1}" | sed 's#\\"#"#g')
          echo "failures"
          echo "${failures}"
          sendMessageViarocketchat() {
            channel="${1}"
          
            message=$(echo "${failures}" | jq -r '.[] | {"pretext": "_INFO_","fields": [{"title": "", "short": true, "value": "- *name:* _ \(.displayName)_\n- *template:* _\(.templateName)_\n- *message:* _\(.message)_\n- *phase:* _\(.phase)_\n- *podName:* _\(.podName)_\n- *finishedAt:* _\(.finishedAt)_\n"}]}' | jq -s .)
            echo "{\"channel\": \"${channel}\", \"author_name\": \"ClusterImageScanner\", \"text\": \"Problem during ClusterImageScanner orchestrator execution\", \"attachments\": ${message}}" > /tmp/slack-template.json
          
            if [ "${ROCKET_CHAT_USER_ID}" == "" ]; then # ROCKET_CHAT_USER_ID comes from cm scanjob-parameter
              echo "No ROCKET_CHAT_USER_ID set"
              exit 3
            fi
            if [ "${SLACK_CLI_TOKEN}" == "" ]; then
              echo "No SLACK_CLI_TOKEN set"
              exit 2
            fi
          
            echo "Sending to rocketchat ${SLACK_MESSAGE_ENDPOINT} ${channel}"
            curl -H "Content-type: application/json" \
              -d @/tmp/slack-template.json \
              -H "X-Auth-Token: ${SLACK_CLI_TOKEN}" \
              -H "X-User-Id: ${ROCKET_CHAT_USER_ID}" \
              -X POST \
              "${SLACK_MESSAGE_ENDPOINT}"
          }
          sendMessageViaslack() {
            channel="${1}"
          
            message=$(echo "${failures}" | jq -r '.[] | {"type": "section","text": {"type": "mrkdwn","text": "- *name:* _ \(.displayName)_\n- *template:* _\(.templateName)_\n- *message:* _\(.message)_\n- *phase:* _\(.phase)_\n- *podName:* _\(.podName)_\n- *finishedAt:* _\(.finishedAt)_\n"}},{"type": "divider"}' | jq -s .)
            echo "{\"channel\": \"${channel}\", \"author_name\": \"ClusterImageScanner\", \"blocks\": ${message}}" > /tmp/slack-template.json
            cat /tmp/slack-template.json
          
            if [ "${SLACK_CLI_TOKEN}" == "" ]; then
              echo "No SLACK_CLI_TOKEN set"
              exit 2
            fi
          
            curl \
              -H "Content-type:application/json" \
              -H "Authorization: Bearer ${SLACK_CLI_TOKEN}" \
              -X POST \
              -d @/tmp/slack-template.json \
              "${SLACK_MESSAGE_ENDPOINT}"
          }
          
          fn_exists() { declare -F "$1" > /dev/null; }
          
          if [[ "${failures}" == "" ]] || [[ "${failures}" == "[]" ]] || [[ "${failures}" == "null" ]]; then
            echo "No message, exit 0" 
            exit 0
          fi
          echo "${MESSAGE_TARGETS}" |  jq -c '.[]' | while read i; do
            channel=$(echo "${i}" | jq -r '.channel')
            type=$(echo "${i}" | jq -r '.type')
            echo "Sending via ${type} to channel ${channel}"
            toCall="sendMessageVia$type"
            if ! fn_exists ${toCall} ; then
              echo "Message type '${type}' doesn't exit"
              exit 1
            fi
          
            ${toCall} "${channel}"
          done
