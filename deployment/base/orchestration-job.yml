apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: orchestration-job-template
  namespace: clusterscanner
spec:
  activeDeadlineSeconds: 3600
  entrypoint: main # Entry point for job execution
  workflowSpec:
    serviceAccountName: clusterscanner
    ttlStrategy:
      secondsAfterSuccess: 86400
      secondsAfterFailure: 86400
    artifactRepositoryRef:
      configMap: artifact-repositories
      key: default-v1
  inputs:
    parameters:
      - workflow.parameters.imageSourceListConfigMapName
      - workflow.parameters.gitSecretName
      - workflow.parameters.scanId
      - workflow.parameters.registrySecretName
      - workflow.parameters.dependencyCheckDbConfigMapName
      - workflow.parameters.defectDojoConfigMapName
      - workflow.parameters.slackTokenSecretName
      - workflow.parameters.emailSecretName
      - workflow.parameters.enforceSlackChannel
      - workflow.parameters.newVersionImageFilter
      - workflow.parameters.dependencyCheckSuppressionsConfigMapName
      - workflow.parameters.allResultsGitTarget
  templates:
    - name: main
      steps:
        - - name: fetch-image-list
            template: fetch-image-list
        - - name: run-subflow
            template: subflow
            arguments:
              artifacts:
                - name: imageList
                  from: "{{steps.fetch-image-list.outputs.artifacts.image-list-merged}}"
        - - name: notify-teams
            template: notify-teams
        - - name: git-upload-report
            template: git-upload-report
            when: "{{ workflow.parameters.allResultsGitTarget }}" != ""

    - name: fetch-image-list
      outputs:
        artifacts:
          - name: image-lists
            path: /clusterscanner/out
            archive:
              none: {}
          - name: image-list-merged
            path: /clusterscanner/out/merged/merged.json
            archive:
              none: {}
      volumes:
        - name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
          configMap:
            name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
        - name: "{{ workflow.parameters.gitSecretName }}"
          secret:
            secretName: "{{ workflow.parameters.gitSecretName }}"
        - name: tmp
          emptyDir: {}
      container:
        image: quay.io/sdase/cluster-image-scanner-image-source-fetcher:2
        imagePullPolicy: IfNotPresent
        volumeMounts:
          - name: "{{ workflow.parameters.gitSecretName }}"
            mountPath: /clusterscanner/github/github_private_key.pem
            subPath: github_private_key.pem
          - name: "{{ workflow.parameters.imageSourceListConfigMapName }}"
            mountPath: /clusterscanner/image-source-list
          - name: tmp
            mountPath: /clusterscanner/out
        env:
          - name: GITHUB_KEY_FILE_PATH
            value: /clusterscanner/github/github_private_key.pem
        envFrom:
          - secretRef:
              name: "{{ workflow.parameters.gitSecretName }}"

    - name: subflow
      inputs:
        artifacts:
          - name: imageList
            path: /clusterscanner/imageList.json
            mode: 0444
      container:
        image: quay.io/sdase/cluster-image-scanner-workflow-runner:2
        imagePullPolicy: IfNotPresent
        env:
          - name: SCAN_ID
            value: "{{ workflow.parameters.scanId }}"
          - name: REGISTRY_SECRET
            value: "{{ workflow.parameters.registrySecretName }}"
          - name: DEPENDENCY_SCAN_CM
            value: "{{ workflow.parameters.dependencyCheckDbConfigMapName }}"
          - name: DEFECTDOJO_CM
            value: "{{ workflow.parameters.defectDojoConfigMapName }}"
          - name: DEFECTDOJO_SECRETS
            value: "{{ workflow.parameters.defectDojoConfigMapName }}"
          - name: MAX_RUNNING_JOBS_IN_QUEUE
            value: "13"
          - name: dependencyCheckSuppressionsConfigMapName
            value: "{{ workflow.parameters.dependencyCheckSuppressionsConfigMapName }}"
          - name: NEW_VERSION_IMAGE_FIILTER
            value: "{{ workflow.parameters.newVersionImageFilter }}"

    - name: notify-teams
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: clusterscanner-scandata
      script:
        image: quay.io/sdase/cluster-image-scanner-notifier:2
        volumeMounts:
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ workflow.parameters.scanId }}"
        imagePullPolicy: Always
        env:
          - name: SLACK_CLI_TOKEN
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.slackTokenSecretName }}"
                key: SLACK_CLI_TOKEN
          - name: ENFORCE_SLACK_CHANNEL
            value: "{{ workflow.parameters.enforceSlackChannel }}"
          - name: smtp
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp
          - name: smtp-auth
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth
          - name: smtp-auth-user
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth-user
          - name: smtp-auth-password
            valueFrom:
              secretKeyRef:
                name: "{{ workflow.parameters.emailSecretName }}"
                key: smtp-auth-password
        command: [/bin/bash]
        source: |
          set -e
          shopt -s globstar nullglob

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi

          inform() {
            echo "image: ${image}, appName ${appName}, team: ${team}, namespace: ${namespace}, environment: ${environment}, ddLink: ${ddLink}, slackChannel: ${slack}, email: ${email}, scanType: ${scanType}, title: ${title}"

            #slack="#nobody-security" # for testing
            if [ "${slack}" != "" ]; then
              if [ "${SLACK_CLI_TOKEN}" == "" ]; then
                echo "SLACK_CLI_TOKEN not set, exit"
                exit 1
              fi
              echo "Sending to slack ${slack}"
              # shellcheck disable=SC2001
              message=$(echo "${message}" | sed 's#"##g')

              ${SLACK_BIN} chat send --actions '{"type": "button", "style": "primary", "text": "Handle potential vulnerabilities", "url": "'${ddLink}'"}' \
                --author 'ClusterScanner' \
                --channel "${slack}" \
                --color bad \
                --fields '{"image": "'${image}'", "app": "'${appName}'", "namespace": "'${namespace}'", "envirnoment": "'${environment}'"}' \
                --footer 'image: '${image}', app: '${appName}', namespace: '${namespace}', envirnoment: '${environment} \
                --footer-icon 'https://assets-cdn.github.com/images/modules/logos_page/Octocat.png' \
                --image 'https://assets-cdn.github.com/images/modules/logos_page/Octocat.png' \
                --pretext "${title}" \
                --text "${message}"
            else
              echo "slackChannel not set"
            fi

            if [ "${email}" != "null" ] && [ "${email}" != "" ]; then
              echo "Sending to email ${email}"
              if [ "${smtp-auth-user}" != "USERNAME@YOURDOMAIN.COM" ] && [ "${smtp-auth-user}" != "" ]; then
                message="$message\nimage: ${image}, app: ${appName}, namespace: ${namespace}, environment: ${environment}, link to DefectDojo: ${ddLink}"
                echo -e "${message}" | mail -s "Found unhandled findings" "${email}" # works
              else
                echo "Warning: email set, but no email configured"
              fi
            else
              echo "Hint: email not set"
            fi
          }

          for file in "${RESULT_PATH}"/**/*.json; do
            echo "found file ${file}"
            item=$(cat "${file}")
            image=$(echo "${item}" | jq -r '.image'| tr -cd '[:alnum:]./@:_-')
            team=$(echo "${item}" | jq -r '.team'| tr -cd '[:alnum:]._-')
            namespace=$(echo "${item}" | jq -r '.namespace'| tr -cd '[:alnum:]._-')
            environment=$(echo "${item}" | jq -r '.environment'| tr -cd '[:alnum:]._-')
            slack=$(echo "${item}" | jq -r '.slack')
            appName=$(echo "${item}" | jq -r '.appname'| tr -cd '[:alnum:]._-')
            email=$(echo "${item}" | jq -r '.email')
            if [ "${ENFORCE_SLACK_CHANNEL}" != "" ]; then
              slack="${ENFORCE_SLACK_CHANNEL}"
            fi
            echo "Inspecting team ${team} for image ${image}"
            for result in $(echo "${item}" | jq -rcM '.uploadResults[] | @base64'); do
              for result2 in $(echo "${result}" | base64 -d | jq -rcM '.[] | @base64'); do
                notifications=$(echo "${result2}" | base64 -d | jq -rcM 'select(.finding == true)')
                while IFS= read -r notification; do
                  echo "in notification for ${image}"
                  ddLinkTest=$(echo "${notification}" | jq -r ".ddLink")
                  message=$(echo "${notification}" | jq -r ".infoText" | sed 's#{#(#g' | sed 's#}#)#g' | sed 's#"#_#g' | tr -cd '[:alnum:]._ \n:@*+()[]-')   # at least { } needs to be removed for the slack cli
                  errorText=$(echo "${notification}" | jq -r ".errorText" | tr -cd '[:alnum:]._ \n:@*+()[]-' || true)
                  status=$(echo "${notification}" | jq -r ".status" | tr -cd '[:alnum:]._ -')
                  ddLinkScheme=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $1}')
                  ddLinkDomain=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $2}')
                  ddLinkBase="${ddLinkScheme}//${ddLinkDomain}"
                  for findingBase in $(echo "${notification}" | jq -rcM '.findings[] | @base64'); do
                    finding=$(echo "${findingBase}" | base64 -d)
                    findingId=$(echo "${finding}" | jq -r '.id' | tr -cd '[:alnum:]._ -')
                    if [ "${findingId}" != "null" ] && [ "${findingId}" != "" ]; then
                      ddLink="${ddLinkBase}/finding/${findingId}"
                    else
                      ddLink="${ddLinkTest}"
                    fi
                    title=$(echo "${finding}" | jq -r '.title' | cut -c1-50 | sed 's#{##g'| sed 's#}##g') #| tr -cd '[:alnum:]._ <>-')
                    title="${title} in ${image}"
                    description=$(echo "${finding}" | jq -r '.description' | sed 's#{##g'| sed 's#}##g')
                    message="${message}\n${description}\nScan Job Status: ${status}"
                    if [ "${errorText}" != "null" ] && [ "${errorText}" != "[]" ] && [ "${errorText}" != "" ]; then
                      message="${message}\nError: ${errorText}"
                    fi
                    output=$(inform "${image}" "${appName}" "${team}" "${namespace}" "${environment}" "${ddLink}" "${slack}" "${email}" "${title}" "${message}" || true)
                    echo "${output}"
                    if [ "$(echo "${output}" | grep -c '"ok": false')" -gt 0 ]; then
                      echo "error in slack"
                      exit 1;
                    fi
                    if [ "$(echo "${output}" | grep -c ratelimited)" -gt 0 ]; then
                      sleep 120 # wait for rate limt
                      inform "${image}" "${appName}" "${team}" "${namespace}" "${environment}" "${ddLink}" "${slack}" "${email}" "${title}" "${message}"
                    fi
                    sleep 1 # reduce risk of rate limit
                  done
                done <<< "${notifications}"
              done
            done
          done

    - name: git-upload-report
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: clusterscanner-scandata
        - name: "{{ workflow.parameters.gitSecretName }}"
          secret:
            secretName: "{{ workflow.parameters.gitSecretName }}"
      script:
        image: quay.io/sdase/cluster-image-scanner-imagecollector:2
        volumeMounts:
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ workflow.parameters.scanId }}"
          - name: "{{ workflow.parameters.gitSecretName }}"
            mountPath: /clusterscanner/github/github_private_key.pem
            subPath: github_private_key.pem
        imagePullPolicy: IfNotPresent
        env:
          - name: SCAN_ID
            value: "{{ workflow.parameters.scanId }}"
          - name: GITHUB_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
          - name: GITHUB_REPOSITORY
            value: "{{ workflow.parameters.allResultsGitTarget }}"
        envFrom:
          - secretRef:
              name: "{{ workflow.parameters.gitSecretName }}"
        command: [/bin/bash]
        source: |
          set -e

          source auth.bash # > /dev/null 2>&1
          source git.bash # > /dev/null 2>&1

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi

          gitAuth
          echo "gitFetch"
          gitFetch

          mkdir /tmp/clusterscanner-remote/${SCAN_ID} || true
          cp -a "${RESULT_PATH}"/* /tmp/clusterscanner-remote/${SCAN_ID}
          cd /tmp/clusterscanner-remote/${SCAN_ID}
          git add * || true
          git commit -m "add" || true

          git push -f origin master || true
