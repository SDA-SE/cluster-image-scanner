apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: orchestration-job-template
  namespace: {{ .Release.Namespace }}
spec:
  onExit: exit-handler
  activeDeadlineSeconds: {{ .Values.orchestrationJob.activeDeadlineSeconds }}
  entrypoint: main # Entry point for job execution
  workflowSpec:
    #serviceAccountName: clusterscanner
    ttlStrategy:
      {{- toYaml .Values.orchestrationJob.ttlStrategy | nindent 6 }}
    artifactRepositoryRef:
      configMap: artifact-repositories
      key: default-v1
  inputs:
    parameters:
      - workflow.parameters.imageSourceListConfigMapName
      - workflow.parameters.gitSecretName
      - workflow.parameters.s3SecretName
      - workflow.parameters.s3ConfigName
      - workflow.parameters.scanId
      - workflow.parameters.registrySecretName
      - workflow.parameters.defectDojoConfigMapName
      - workflow.parameters.slackTokenSecretName
      - workflow.parameters.emailSecretName
      - workflow.parameters.enforceSlackChannel
      - workflow.parameters.enforceMail
      - workflow.parameters.newVersionImageFilter
      - workflow.parameters.allResultsGitTarget
      - workflow.parameters.imageRegistryBase
      - workflow.parameters.clusterImageScannerImageTag
      - workflow.parameters.errorTargets

  templates:
    - name: main
      steps:
        - - name: fetch-image-list
            template: fetch-image-list
        - - name: run-subflow
            template: subflow
            arguments:
              artifacts:
                - name: imageList
                  from: "{{ "{{" }}steps.fetch-image-list.outputs.artifacts.image-list-merged{{ "}}" }}"
        - - name: notify-teams
            template: notify-teams
        - - name: generate-lifetime-statistics
            template: generate-lifetime-statistics
        #            when: "{{ "{{" }} workflow.parameters.allResultsGitTarget {{ "}}" }} == "
        - - name: generate-response-statistics
            template: generate-response-statistics
        - - name: git-upload-response-statistics
            template: git-upload-response-statistics
            arguments:
              artifacts:
                - name: team-statistics
                  from: "{{ "{{" }}steps.generate-response-statistics.outputs.artifacts.team-statistics{{ "}}" }}"
        - - name: cleanup-dependency-track
            template: cleanup-dependency-track

    - name: fetch-image-list
      outputs:
        artifacts:
          - name: image-lists
            path: /clusterscanner/out
            archive:
              none: {}
          - name: image-list-merged
            path: /clusterscanner/out/merged/merged.json
            archive:
              none: {}
      volumes:
        - name: "{{ "{{" }} workflow.parameters.imageSourceListConfigMapName {{ "}}" }}"
          configMap:
            name: "{{ "{{" }} workflow.parameters.imageSourceListConfigMapName {{ "}}" }}"
        - name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
          secret:
            secretName: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
        - name: out
          emptyDir: {}
        - name: tmp
          emptyDir: {}
      container:
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/cluster-image-scanner-image-source-fetcher:{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}"
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        command: ["/clusterscanner/entrypoint.bash"]
        resources:
          {{- toYaml .Values.orchestrationJob.fetchImageList.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        volumeMounts:
          - name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
          - name: "{{ "{{" }} workflow.parameters.imageSourceListConfigMapName {{ "}}" }}"
            mountPath: /clusterscanner/image-source-list
          - name: tmp
            mountPath: /tmp
          - name: out
            mountPath: /clusterscanner/out
        env:
          - name: GH_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
        envFrom:
          - secretRef:
              name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
          - secretRef:
              name: "{{ "{{" }} workflow.parameters.s3SecretName {{ "}}" }}"
          - configMapRef:
              name: "scanjob-env-parameter"
          - configMapRef:
              name: "{{ "{{" }} workflow.parameters.s3ConfigName {{ "}}" }}"

    - name: subflow
      volumes:
        - name: tmp
          emptyDir: {}
      inputs:
        artifacts:
          - name: imageList
            path: /clusterscanner/imageList.json
            mode: 0444
      container:
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        resources:
          {{- toYaml .Values.orchestrationJob.subflow.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/cluster-image-scanner-workflow-runner:{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}"
        command: ["/clusterscanner/entrypoint.bash"]
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
        env:
          - name: SCAN_ID
            value: "{{ "{{" }} workflow.parameters.scanId {{ "}}" }}"
          - name: REGISTRY_SECRET
            value: "{{ "{{" }} workflow.parameters.registrySecretName {{ "}}" }}"
          - name: DEPENDENCY_SCAN_CM
            value: "{{ "{{" }} workflow.parameters.dependencyCheckDbConfigMapName {{ "}}" }}"
          - name: DEFECTDOJO_CM
            value: "{{ "{{" }} workflow.parameters.defectDojoConfigMapName {{ "}}" }}"
          - name: DEFECTDOJO_SECRETS
            value: "{{ "{{" }} workflow.parameters.defectDojoConfigMapName {{ "}}" }}"
          - name: dependencyCheckSuppressionsConfigMapName
            value: "{{ "{{" }} workflow.parameters.dependencyCheckSuppressionsConfigMapName {{ "}}" }}"
          - name: imageRegistryBase
            value: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}"
          - name: clusterImageScannerImageTag
            value: "{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}"
          - name: "slackTokenSecretName"
            value: "{{ "{{" }} workflow.parameters.slackTokenSecretName {{ "}}" }}"
          - name: errorTargets
            value: "{{ "{{" }} workflow.parameters.errorTargets {{ "}}" }}"
          - name: IS_PRINT_TEMPLATE
            value: "true" # TODO false

    - name: notify-teams
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: cluster-image-scanner-scandata
        - name: tmp
          emptyDir: {}
      script:
        resources:
          {{- toYaml .Values.orchestrationJob.notifyTeams.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/cluster-image-scanner-notifier:{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}" # has mailx
        volumeMounts:
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ "{{" }} workflow.parameters.scanId {{ "}}" }}"
          - name: tmp
            mountPath: /tmp
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        env:
          - name: SLACK_CLI_TOKEN
            valueFrom:
              secretKeyRef:
                name: "{{ "{{" }} workflow.parameters.slackTokenSecretName {{ "}}" }}"
                key: SLACK_CLI_TOKEN
          - name: ENFORCE_SLACK_CHANNEL
            value: "{{ "{{" }} workflow.parameters.enforceSlackChannel {{ "}}" }}"
          - name: SCAN_NEW_VERSION_TOLERANCE_DAYS # time, in which the new version finding is in DefectDojo, but teams are not notified
            value: "4"
          - name: smtp-auth-password
            valueFrom:
              secretKeyRef:
                name: "{{ "{{" }} workflow.parameters.emailSecretName {{ "}}" }}"
                key: smtp-auth-password
          - name: smtpauthpassword
            valueFrom:
              secretKeyRef:
                name: "{{ "{{" }} workflow.parameters.emailSecretName {{ "}}" }}"
                key: smtp-auth-password
          - name: SLACK_MESSAGE_ENDPOINT
            value: "https://slack.com/api/chat.postMessage"
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
          - configMapRef:
              name: "email-parameter"
        command: [/bin/bash]
        source: |
          shopt -s globstar nullglob

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi

          rm -Rf /tmp/email/ || true
          rm -Rf /tmp/slack/ || true

          inputAsFileSystem() {
            local notificationTarget="${1}" # e.g. mail, slack
            # shellcheck disable=SC2001
            echo "exporting notificationTargetForFs"
            export notificationTargetForFs=$(echo ${notificationTarget} | sed 's/@//g' | sed "s/'//g" | sed 's#"##g'| sed 's|#||g' | sed 's|\n||g' )
          }

          createNotificationSlack() {
            if [ "${SLACK_CLI_TOKEN}" == "" ]; then
              echo "SLACK_CLI_TOKEN not set, exit"
              return;
            fi
            local image="${1}"
            local appName="${2}"
            local team="${3}"
            local namespace="$4"
            local environment="$5"
            local ddLink="$6"
            local scanType="$7"
            local title="$8"
            local info="$9"
            local status="${10}"
            local findingSeverity="${11}"
            local findingDescription="${12}"
            local slack="${13}"
            if [ "${slack}" == "null" ]; then slack=""; fi
            if [ "${slack}" == "" ]; then
              echo "Slack channel not set"
              return;
            fi
            echo "In createNotificationSlack, image: ${image}, appName ${appName}, team: ${team}, namespace: ${namespace}, environment: ${environment}, ddLink: ${ddLink}, scanType: ${scanType}, title: ${title}, info: ${infoText}, status: ${status}"

            slackChannels=$(echo "${slackChannels}
            ${slack}" | sort  | uniq)

            inputAsFileSystem ${slack@Q}
            echo "notificationTargetForFs slack: ${notificationTargetForFs}"
            mkdir -p /tmp/slack/${notificationTargetForFs} || true
            SLACK_TEMPLATE_ONE_BLOCK_TARGET=$(mktemp --tmpdir=/tmp/slack/${notificationTargetForFs})
            echo "replacing template placeholder for slack"
            cat "${SLACK_TEMPLATE_ONE_BLOCK}" | sed "s#\#\#\#TITLE\#\#\##${title}#g"  > ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            sed -i "s|###STATUS###|${status}|g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            sed -i "s|###DD_LINK###|${ddLink}|g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            sed -i "s#\#\#\#IMAGE\#\#\##${image}#g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            sed -i "s#\#\#\#APP_NAME\#\#\##${appName}#g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            sed -i "s/###NAMESPACE###/${namespace}/g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            sed -i "s/###ENVIRONMENT###/${environment}/g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            sed -i "s|###SEVERITY###|${findingSeverity}|g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
            infoNoNewline=$(echo ${info} | sed 's#"##g'| sed 's|#||g' | sed 's|\n|; |g')
            sed -i "s#_INFO_#${infoNoNewline}#g" ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}

            echo "${SLACK_TEMPLATE_ONE_BLOCK_TARGET}:"
            cat ${SLACK_TEMPLATE_ONE_BLOCK_TARGET}
          }

          createNotificationMail() {
            local image="${1}"
            local appName="${2}"
            local team="${3}"
            local namespace="$4"
            local environment="$5"
            local ddLink="$6"
            local scanType="$7"
            local title="$8"
            local info="$9"
            local status="${10}"
            local findingSeverity="${11}"
            local findingDescription="${12}"
            local email="${13}"
            echo "In createNotificationMail, image: ${image}, appName ${appName}, team: ${team}, namespace: ${namespace}, environment: ${environment}, ddLink: ${ddLink}, scanType: ${scanType}, title: ${title}, info: ${infoText}, status: ${status}"

            emails=$(echo "${emails}
                        ${email}" | sort  | uniq)

            inputAsFileSystem "${email@Q}"
            mkdir -p /tmp/email/${notificationTargetForFs} || true
            MAIL_TEMPLATE_ONE_BLOCK_TARGET=$(mktemp --tmpdir=/tmp/email/${notificationTargetForFs})

            message="image: ${image},\napp: ${appName},\nnamespace: ${namespace},\nenvironment: ${environment},\nlink to DefectDojo: ${ddLink},\ninfo: ${infoText},\nstatus: ${status}"
            echo "${message}" > ${MAIL_TEMPLATE_ONE_BLOCK_TARGET}
          }

          sendNotificationsSlack() {
            if [ "${SLACK_CLI_TOKEN}" == "" ]; then
              echo "SLACK_CLI_TOKEN not set, exit"
              return;
            fi
            notificationPath="${1}"
            slack="${2}"

            echo "ls"
            ls ${notificationPath}/*
            echo "gathering  ${notificationPath}/"
            blocks=$(jq -n '[ inputs[]]' $(ls ${notificationPath}/*))
            #slack="#nobody-security" # for testing
            echo "Replacing slack \"${slack}\" channel"
            cat ${SLACK_TEMPLATE} | sed "s/###SLACK_CHANNEL###/${slack}/g" > /tmp/slack-message-for-one-channel.json
            echo "/tmp/slack-message-for-one-channel.json"
            cat /tmp/slack-message-for-one-channel.json
            echo "replacing blocks with $blocks"
            #sed "s|###BLOCKS###|${blocks}|g" /tmp/slack-message-for-one-channel.json
            jq --argjson block "${blocks}" '.blocks = $block' /tmp/slack-message-for-one-channel.json > /tmp/combined-blocks.json

            echo "Sending to slack ${slack} with messageendpoint ${SLACK_MESSAGE_ENDPOINT}"
            curl \
              -H "Content-type:application/json" \
              -H "Authorization: Bearer ${SLACK_CLI_TOKEN}" \
              -X POST \
              -d @/tmp/combined-blocks.json \
              "${SLACK_MESSAGE_ENDPOINT}"
          }

          sendNotificationsMail() {
            local notificationPath="${1}"
            local email="${2}"
            if [ "${email}" == "null" ] || [ "${email}" == "" ]; then
              return;
            fi
            if [ "${smtpauthpassword}" == "YOURPASSWORD" ] || [ "${smtpauthpassword}" == "" ] || [ "${smtpauthpassword}" == "smtp_auth_password_SECRET" ]; then
              echo "Warning: email set, but no email configured"
              return
            fi

            message=""
            for file in $(ls ${notificationPath}/); do
              message="${message}\n---\n$(cat ${notificationPath}/${file})"
            done

            echo "Preparing to send email to ${email}"
            mailParameter=""
            if [ "${SMTP_MAILFROM}" != "" ]; then
              mailParameter=" -S from=${SMTP_MAILFROM} "
            fi
            echo "Checking SMTP_START_TLS ${SMTP_START_TLS}"
            if [ "${SMTP_START_TLS}" == "true" ]; then
              mailParameter="${mailParameter} -S smtp-use-starttls "
            fi
            echo "Checking SMTP_MAIL_PARAMETER ${SMTP_MAIL_PARAMETER}"
            if [ "${SMTP_MAIL_PARAMETER}" != "" ]; then
              mailParameter=" ${mailParameter} ${SMTP_MAIL_PARAMETER} "
            fi
            if [ "${SMTP_ENFORCE_MAILTO}" != "" ]; then
              echo "Enforcing mailto override to ${SMTP_ENFORCE_MAILTO}"
              email="${SMTP_ENFORCE_MAILTO}"
            fi
            echo "echo -e \"${message}\" | mail ${mailParameter} -s \"Found unhandled findings\" \"${email}\""
            echo -e "${message}" | mail ${mailParameter} -s "Found unhandled findings" "${email}" || echo "ERROR during sending ${message}"
          }
          errors=""
          echo "Will iterate over files in ${RESULT_PATH}"
          for file in "${RESULT_PATH}"/**/*.json; do
            echo "found file ${file}"
            item=$(cat "${file}")
            image=$(echo "${item}" | jq -r '.image'| tr -cd '[:alnum:]./@:_-')
            team=$(echo "${item}" | jq -r '.team'| tr -cd '[:alnum:]._-')
            namespace=$(echo "${item}" | jq -r '.namespace'| tr -cd '[:alnum:]._-')
            environment=$(echo "${item}" | jq -r '.environment'| tr -cd '[:alnum:]._-')
            slack=$(echo "${item}" | jq -r '.slack')
            appName=$(echo "${item}" | jq -r '.appname'| tr -cd '[:alnum:]._-')
            email=$(echo "${item}" | jq -r '.email')
            if [ -n "${ENFORCE_SLACK_CHANNEL}" ]; then
              slack="${ENFORCE_SLACK_CHANNEL}"
            fi
            echo "Inspecting team ${team} for image ${image}"
            for result in $(echo "${item}" | jq -rcM '.uploadResults[] | @base64'); do
              for result2 in $(echo "${result}" | base64 -d | jq -rcM '.[] | @base64'); do
                notifications=$(echo "${result2}" | base64 -d | jq -rcM 'select(.finding == true)')
                while IFS= read -r notification; do
                  echo "in notification for ${image}"
                  ddLinkTest=$(echo "${notification}" | jq -r ".ddLink")
                  echo "after defining ddLinkTest"
                  echo "${notification}" | jq -r ".infoText"
                  # shellcheck disable=SC2001
                  infoText=$(echo "${notification}" | jq -r ".infoText" | sed 's#{#(#g' | sed 's#}#)#g' | sed 's#"#_#g' | tr -cd '[:alnum:]._ \n:@*+()[]-')   # at least { } needs to be removed for the slack cli
                  info=$(echo "${infoText}" | sed 's#"##g'| sed 's|#||g' | sed 's|\n||g')
                  echo "after defining info"
                  errorText=$(echo "${notification}" | jq -r ".errorText" | tr -cd '[:alnum:]._ \n:@*+()[]-' || true)
                  status=$(echo "${notification}" | jq -r ".status" | tr -cd '[:alnum:]._ -')
                  ddLinkScheme=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $1}')
                  ddLinkDomain=$(echo "${ddLinkTest}" | tr '/' ' ' | awk '{print $2}')
                  ddLinkBase="${ddLinkScheme}//${ddLinkDomain}"
                  for findingBase in $(echo "${notification}" | jq -rcM '.findings[] | @base64'); do
                    echo "In findingBase for ${image}"
                    finding=$(echo "${findingBase}" | base64 -d)
                    findingId=$(echo "${finding}" | jq -r '.id' | tr -cd '[:alnum:]._ -')
                    if [ "${findingId}" != "null" ] && [ "${findingId}" != "" ]; then
                      ddLink="${ddLinkBase}/finding/${findingId}"
                    else
                      ddLink="${ddLinkTest}"
                    fi
                    echo "findingId ${findingId}"
                    title=$(echo "${finding}" | jq -r '.title' | cut -c1-50 | sed 's#{##g'| sed 's#}##g') #| tr -cd '[:alnum:]._ <>-')
                                        if [ "$title" == "Image Has a New Version" ]; then
                                          echo "In new version, skipping. In a later version, we will inform after X days"
                                          continue;

                    #                      echo "item: ${item}"
                    #                      scanResultFindingFinishedAt=$(echo "${item}" | jq -r '.scanResults[]["scan-new-version"].cachedUsedAt' | grep -v null) # doesn't work
                    #                      echo "scanResultFindingFinishedAt ${scanResultFindingFinishedAt}"
                    #                      t1=$(date --date="${scanResultFindingFinishedAt}" +%s)
                    #                      # Current date
                    #                      dt2=$(date +%Y-%m-%d\ %H:%M:%S)
                    #                      # Compute the seconds since epoch for date 2
                    #                      t2=$(date --date="${dt2}" +%s)
                    #                      # difference in dates in seconds
                    #                      tDiff="$(( t2-t1 ))"
                    #                      # hour difference
                    #                      hDiff="$(( tDiff/3600 ))" || true
                    #                      # day difference
                    #                      dDiff="$(( hDiff/24 ))" || true
                    #                      echo "t1: ${t1}, t2: ${t2}, dDiff: ${dDiff}"
                    #                      if [ ${dDiff} -lt ${SCAN_NEW_VERSION_TOLERANCE_DAYS} ]; then
                    #                        echo "${dDiff} is less than ${SCAN_NEW_VERSION_MAX_TOLERANCE_DAYS}, skipping notification of ${image} in ${namespace} on ${environment}"
                    #                        continue
                    #                      fi
                                        fi
                    title="${title} in ${image}"
                    echo "${title}"
                    findingSeverity=$(echo "${finding}" | jq -r ".severity" | tr -cd '[:alnum:]._ -')
                    findingDescription=$(echo "${finding}" | jq -r '.description' | sed 's#{##g'| sed 's#}##g'  | tr -cd '[:alnum:]._ \n:@*+()[]-' | sed 's|#||g')
                    message="${infoText}; ${description}"
                    echo "created message, will create error if exists"
                    if [ "${errorText}" != "null" ] && [ "${errorText}" != "[]" ] && [ "${errorText}" != "" ]; then
                      message="${message}\nError: ${errorText}"
                      infoText="${infoText}; Error: ${errorText}"
                    fi
                    echo "will inform ${image}"
                    createNotificationSlack "${image}" "${appName}" "${team}" "${namespace}" "${environment}" "${ddLink}" "${scanType}" "${title}" "${info}" "${status}" "${findingSeverity}" "${findingDescription}" "${slack}"
                    createNotificationMail "${image}" "${appName}" "${team}" "${namespace}" "${environment}" "${ddLink}" "${scanType}" "${title}" "${info}" "${status}" "${findingSeverity}" "${findingDescription}" "${email}"
                  done
                done <<< "${notifications}"
              done
            done
          done
          for email in ${emails}; do
            inputAsFileSystem "${email}"
            sendNotificationsMail "/tmp/email/${notificationTargetForFs}" "${email}"
          done
          echo "slackChannels $slackChannels"
          for slack in ${slackChannels}; do
            echo "slack $slack"
            inputAsFileSystem "${slack}"
            sendNotificationsSlack "/tmp/slack/${notificationTargetForFs}" "${slack}"
          done
          echo "${errors}"

    - name: generate-lifetime-statistics
      volumes:
        - name: scandata
          persistentVolumeClaim:
            claimName: cluster-image-scanner-scandata
        - name: tmp
          emptyDir: {}
        - name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
          secret:
            secretName: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
      script:
        resources:
          {{- toYaml .Values.orchestrationJob.generateLifetimeStatistics.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/cluster-image-scanner-imagecollector:{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}"
        volumeMounts:
          - name: tmp
            mountPath: /tmp
          - name: scandata
            mountPath: /clusterscanner/data
            subPath: "{{ "{{" }} workflow.parameters.scanId {{ "}}" }}"
          - name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        env:
          - name: ENVIRNOMENT
            value: "{{ "{{" }} workflow.parameters.scanId {{ "}}" }}"
          - name: SCAN_ID
            value: "{{ "{{" }} workflow.parameters.scanId {{ "}}" }}"
          - name: GH_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
          - name: GIT_REPOSITORY
            value: "{{ "{{" }} workflow.parameters.allResultsGitTarget {{ "}}" }}"
          - name: WORKFLOW_DATE
            value: "{{ "{{" }} workflow.creationTimestamp.Y {{ "}}" }}{{ "{{" }} workflow.creationTimestamp.m {{ "}}" }}{{ "{{" }} workflow.creationTimestamp.d {{ "}}" }}"
        envFrom:
          - secretRef:
              name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
          - configMapRef:
              name: "scanjob-env-parameter"
        command: [/bin/bash]
        source: |
          set -e
          cd $HOME

          source auth.bash # > /dev/null 2>&1
          source git.bash # > /dev/null 2>&1

          if [ "${GIT_SSH_REPOSITORY_HOST}" == "SET-ME" ] && [ "${GH_INSTALLATION_ID}" == "" ]; then
            echo "GIT_SSH_REPOSITORY_HOST and GH_INSTALLATION_ID not configured, skipping"
            exit 0
          fi
          echo "GIT_REPOSITORY $GIT_REPOSITORY"

          if [ "${RESULT_PATH}" == "" ]; then
            RESULT_PATH=/clusterscanner/data
          fi

          if [ "${GIT_REPOSITORY}" == "" ]; then
            echo "No repo to upload stats"
            exit 0
          fi

          gitAuth
          echo "gitFetch"
          gitFetch


          tmpdir=$(mktemp -d)
          tmpdirBaseImage=$(mktemp -d)
          mkdir /tmp/clusterscanner-remote/${WORKFLOW_DATE} || true
          # echo "tmpdir: ${tmpdir}, tmpdirBaseImage: ${tmpdirBaseImage}"
          echo "${RESULT_PATH}"
          ls -la "${RESULT_PATH}"
          for result in $(find ${RESULT_PATH} -name *.json); do
            team=$(cat $result | jq -r '.team' | sed 's/\s//g' || true)
            age=$(cat $result | jq -r '.scanResults[] | .["scan-lifetime"].age' | grep -v null || true)
            baseImageAge=$(cat $result | jq -r '.scanResults[] | .["scan-baseimage-lifetime"].age' | grep -v null || true)
            environment=$(cat $result | jq -r '.environment' | sed 's/\s//g' || true)
            image=$(cat $result | jq -r '.image' | sed 's/\s//g' || true)
            reproducibleBuildImage="false"
            reproducibleBuildBaseImage="false"
            for keyBase64 in $(cat $result | jq -r '.scanResults[]  | @base64'); do
              key=$(echo ${keyBase64} | base64 -d)
              if [ "$(echo $key | jq '. | has("scan-lifetime")')" == "true" ] && [ "$(echo "${key}" | jq -r '.["scan-lifetime"] | has("reproducibleBuild")')" == "true" ]; then
                echo "scan-lifetime found"
                reproducibleBuildImage=$(echo ${key} | jq -r '.["scan-lifetime"].reproducibleBuild' | grep -v null)
              else
                echo "scan-lifetime not found"
              fi
              if [ "$(echo ${key} | jq '. | has("scan-baseimage-lifetime")')" == "true"  ] && [ "$(echo "${key}" | jq -r '.["scan-baseimage-lifetime"] | has("reproducibleBuild")')" == "true" ] ; then
                echo "scan-baseimage-lifetime found"
                reproducibleBuildBaseImage=$(echo ${key} | jq -r '.["scan-baseimage-lifetime"].reproducibleBuild' | grep -v null)
              else
                echo "scan-baseimage-lifetime not found"
              fi
            done

            if [ "${age}" != "" ]; then
              if [ "${reproducibleBuildImage}" == "true" ]; then
                echo "Skipping age for ${image} due to reproducibleBuildImage"
                echo "${image} ${age}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${environment}_invalid_creation_date_image-lifetime_${team}.txt
              else
                echo ${age} >> ${tmpdir}/${environment}_${team}.txt
              fi
            fi
            if [ "${baseImageAge}" != "" ]; then
              if [ "${reproducibleBuildBaseImage}" == "true" ]; then
                echo "Skipping baseImageAge for ${image} due to reproducibleBuildImage"
                echo "${image} ${baseImageAge}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${environment}_invalid_creation_date_baseimage-lifetime_$${team}.txt
              else
                echo ${baseImageAge} >> ${tmpdirBaseImage}/${environment}_${team}.txt
              fi
            fi
          done
          echo "${tmpdir}"
          ls -la "${tmpdir}"

          for j in $(ls ${tmpdir}); do
            result=$(cat ${tmpdir}/${j}  | awk '{if(min==""){min=max=$1}; if($1>max) {max=$1}; if($1<min) {min=$1}; total+=$1; count+=1} END {print total/count, max, min}')
            filename=$(echo ${j} | sed 's#.txt##g')
            echo "lifetime for images is (avg max min) ${result}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${filename}_lifetime.txt
            echo "${result} ${filename}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv
          done
          cat /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv | sort -n >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview-tmp.csv
          mv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview-tmp.csv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/lifetime_overview.csv

          for j in $(ls ${tmpdirBaseImage}); do
            result=$(cat ${tmpdirBaseImage}/${j}  | awk '{if(min==""){min=max=$1}; if($1>max) {max=$1}; if($1<min) {min=$1}; total+=$1; count+=1} END {print total/count, max, min}')
            filename=$(echo ${j} | sed 's#.txt##g')
            echo "baseimage lifetime for images is (avg max min) ${result}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/${filename}_baseimage-lifetime.txt
            echo " ${result} ${filename}" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv
          done
          cat /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv | sort -n >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview-tmp.csv
          mv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview-tmp.csv /tmp/clusterscanner-remote/${WORKFLOW_DATE}/baseimage_lifetime_overview.csv

          echo "Start (SCAN_ID): ${SCAN_ID}, end: $(date)" >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/infos.txt

          cd /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          ls -la /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          git add * || true
          git commit -m "add" || true

          git push -f origin master || true


    - name: generate-response-statistics
      outputs:
        artifacts:
          - name: team-statistics
            path: /tmp/team-response-statistics.csv
      volumes:
        - name: tmp
          emptyDir: { }
      container:
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        resources:
          {{- toYaml .Values.orchestrationJob.generateResponseStatistics.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/defectdojo-statistic-client:3"
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        command: [ "java", "-cp", "@/app/jib-classpath-file", "org.sdase.Main" ]
        envFrom:
          - configMapRef:
              name: "{{ "{{" }} workflow.parameters.defectDojoConfigMapName {{ "}}" }}"
          - configMapRef:
              name: "scanjob-env-parameter"
          - secretRef:
              name: "{{ "{{" }} workflow.parameters.defectDojoConfigMapName {{ "}}" }}"

    - name: git-upload-response-statistics
      volumes:
        - name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
          secret:
            secretName: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
        - name: tmp
          emptyDir: {}
      inputs:
        artifacts:
          - name: team-statistics
            path: /tmp/team-response-statistics.csv
      script:
        resources:
          {{- toYaml .Values.orchestrationJob.gitUploadResponseStatistics.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/cluster-image-scanner-imagecollector:{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}"
        volumeMounts:
          - name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
            mountPath: "/clusterscanner/github/github_private_key.pem"
            subPath: "github_private_key.pem"
          - name: tmp
            mountPath: /tmp
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        env:
          - name: SCAN_ID
            value: "{{ "{{" }} workflow.parameters.scanId {{ "}}" }}"
          - name: GH_KEY_FILE_PATH
            value: "/clusterscanner/github/github_private_key.pem"
          - name: GIT_REPOSITORY
            value: "{{ "{{" }} workflow.parameters.allResultsGitTarget {{ "}}" }}"
          - name: WORKFLOW_DATE
            value: "{{ "{{" }} workflow.creationTimestamp.Y {{ "}}" }}{{ "{{" }} workflow.creationTimestamp.m {{ "}}" }}{{ "{{" }} workflow.creationTimestamp.d {{ "}}" }}"
        envFrom:
          - secretRef:
              name: "{{ "{{" }} workflow.parameters.gitSecretName {{ "}}" }}"
          - configMapRef:
              name: "scanjob-env-parameter"
        command: [/bin/bash]
        source: |
          set -e
          cd $HOME

          source auth.bash # > /dev/null 2>&1
          source git.bash # > /dev/null 2>&1

          if [ "${GIT_SSH_REPOSITORY_HOST}" == "SET-ME" ] && [ "${GH_INSTALLATION_ID}" == "" ]; then
            echo "GIT_SSH_REPOSITORY_HOST and GH_INSTALLATION_ID not configured, skipping"
            exit 0
          fi

          if [ "${GIT_REPOSITORY}" == "" ]; then
            echo "No repo to upload stats"
            exit 0
          fi

          gitAuth
          echo "gitFetch"
          gitFetch

          mkdir /tmp/clusterscanner-remote/${WORKFLOW_DATE} || true
          cat /tmp/team-response-statistics.csv >> /tmp/clusterscanner-remote/${WORKFLOW_DATE}/team-response-statistics.csv
          cd /tmp/clusterscanner-remote/${WORKFLOW_DATE}
          ls -la /tmp/clusterscanner-remote/${WORKFLOW_DATE}

          git add * || true
          git commit -m "add response statistics" || true

          git push -f origin master || true


    - name: cleanup-dependency-track
      volumes:
        - name: tmp
          emptyDir: { }
      script:
        resources:
          {{- toYaml .Values.orchestrationJob.cleanupDTrack.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/cluster-image-scanner-base:{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}"
        command: [/bin/bash]
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        envFrom:
          - secretRef:
              name: "dependency-track"
          - configMapRef:
              name: "scanjob-env-parameter"
          - configMapRef:
              name: "dependency-track"
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        source: |
          if [ "${DEPENDENCY_TRACK_DAYS_TO_KEEP_PROJECT_WITHOUT_UPLOAD}" == "0" ]; then
            echo "DEPENDENCY_TRACK_DAYS_TO_KEEP_PROJECT_WITHOUT_UPLOAD is set 0, exit"
            exit 0
          fi
          if [ "${DEPENDENCY_TRACK_URL}" == "" ]; then
            echo "DEPENDENCY_TRACK_URL is empty, exit"
            exit 0
          fi
          now=$(date +"%s");
          oneDayInSec=86400;
          maxAge=$(($now-$oneDayInSec*${DEPENDENCY_TRACK_DAYS_TO_KEEP_PROJECT_WITHOUT_UPLOAD}));
          echo "maxAge: ${maxAge}"
          # TODO: Paging in case this uses up to much RAM
          content=$(curl "${DEPENDENCY_TRACK_URL}/api/v1/project?excludeInactive=true&=" \
            --silent \
            --show-error \
            --header 'Accept: application/json' \
            -H "X-API-Key: ${DEPENDENCY_TRACK_KEY}")
          echo $content | jq -r ".[] | select(.lastBomImport > ${maxAge}) | .uuid" > /tmp/projects-to-set-inactive

          for uuid in $(cat /tmp/projects-to-set-inactive); do
            echo "UUID $uuid"
            name=$(curl  \
              -H 'Content-Type: application/json' \
              -H "X-API-Key: ${DEPENDENCY_TRACK_KEY}" \
              --silent \
              --show-error \
            "${DEPENDENCY_TRACK_URL}/api/v1/project/${uuid}" | jq '.name')
            nameParameterUrlEncoded=$(printf %s "${name}" | jq -sRr @uri)
            echo '{ "name": "'${nameParameterUrlEncoded}'", "uuid": "'${uuid}'", "active": false}' > /tmp/tmpfile
            echo "After a test period, we will set ${nameParameterUrlEncoded} with UUID ${uuid} to active=false"
            #curl -X "PUT" \
            #  -H 'Content-Type: application/json' \
            #  -H "X-API-Key: ${DEPENDENCY_TRACK_KEY}" \
            #  -d @/tmp/tmpfile \
            #  --silent \
            #  --show-error \
            #  "${DEPENDENCY_TRACK_URL}/api/v1/project"
          done

    - name: exit-handler
      volumes:
        - name: tmp
          emptyDir: { }
      script:
        command: [/bin/bash]
        resources:
          {{- toYaml .Values.orchestrationJob.exitHandler.resources | nindent 10 }}
        securityContext:
          {{- toYaml .Values.orchestrationJob.securityContext | nindent 10 }}
        image: "{{ "{{" }} workflow.parameters.imageRegistryBase {{ "}}" }}/cluster-image-scanner-base:{{ "{{" }} workflow.parameters.clusterImageScannerImageTag {{ "}}" }}"
        imagePullPolicy: {{ .Values.orchestrationJob.imagePullPolicy }}
        env: # TODO check for email creds
          - name: MESSAGE_TARGETS
            value: "{{ "{{" }} workflow.parameters.errorTargets {{ "}}" }}"
          - name: SLACK_CLI_TOKEN
            valueFrom:
              secretKeyRef:
                name: "{{ "{{" }} workflow.parameters.slackTokenSecretName {{ "}}" }}"
                key: SLACK_CLI_TOKEN
        envFrom:
          - configMapRef:
              name: "scanjob-env-parameter"
        volumeMounts:
          - name: tmp
            mountPath: /tmp
        source: |
          if [ "${MESSAGE_TARGETS}" == "" ]; then
            echo "MESSAGE_TARGETS set, exiting"
            exit 1
          fi
          if [ "${JOB_EXECUTION_NAMESPACE}" == "" ]; then # comming from scanjob-parameter
            JOB_EXECUTION_NAMESPACE="clusterscanner"
          fi
          failures='{{ "{{" }}workflow.failures{{ "}}" }}'
          failures=$(echo "${failures:1:-1}" | sed 's#\\"#"#g')
          echo "failures"
          echo "${failures}"
          sendMessageViaslack() {
            channel="${1}"

            message=$(echo "${failures}" | jq -r '.[] | {"type": "section","text": {"type": "mrkdwn","text": "- *name:* _ \(.displayName)_\n- *template:* _\(.templateName)_\n- *message:* _\(.message)_\n- *phase:* _\(.phase)_\n- *podName:* _\(.podName)_\n- *finishedAt:* _\(.finishedAt)_\n"}},{"type": "divider"}' | jq -s .)
            echo "{\"channel\": \"${channel}\", \"author_name\": \"ClusterImageScanner\", \"blocks\": ${message}}" > ${SLACK_TEMPLATE_ONE_BLOCK}
            cat ${SLACK_TEMPLATE_ONE_BLOCK}

            if [ "${SLACK_CLI_TOKEN}" == "" ]; then
              echo "No SLACK_CLI_TOKEN set"
              exit 2
            fi

            curl \
              -H "Content-type:application/json" \
              -H "Authorization: Bearer ${SLACK_CLI_TOKEN}" \
              -X POST \
              -d @${SLACK_TEMPLATE_ONE_BLOCK} \
              "${SLACK_MESSAGE_ENDPOINT}"
          }

          fn_exists() { declare -F "$1" > /dev/null; }

          if [[ "${failures}" == "" ]] || [[ "${failures}" == "[]" ]] || [[ "${failures}" == "null" ]]; then
            echo "No message, exit 0"
            exit 0
          fi
          echo "${MESSAGE_TARGETS}" |  jq -c '.[]' | while read i; do
            channel=$(echo "${i}" | jq -r '.channel')
            type=$(echo "${i}" | jq -r '.type')
            echo "Sending via ${type} to channel ${channel}"
            toCall="sendMessageVia$type"
            if ! fn_exists ${toCall} ; then
              echo "Message type '${type}' doesn't exit"
              exit 1
            fi

            ${toCall} "${channel}"
          done
